## 理论知识

1、什么时候重试？

- **网络异常**：如 `IOException`、`SocketTimeoutException` 等。
- **HTTP 状态码**：如 HTTP 状态码为 500 和 400 。
- **自定义异常**：例如，根据 HTTP 响应的 JSON 内容（如 `code` 字段）来抛出自定义异常。

2、重试策略

- 对于三方的 http 接口，重试了之后，如果还是失败，并且是 dns 解析异常，则通过 ip和端口 再请求并执行相同的重试策略
- 动态判断服务器性能指标决定是否测试
- [区分偶发性超时和频繁超时的重试策略](https://www.mianshi.icu/case/detail?id=32)
- 对于非关键路径的接口调用，可以将同步转为异步调用
- 对于不经常变化的数据，可以在客户端进行缓存，减少对服务端的请求压力

## 1. 使用 Spring Retry

Spring Retry 是一个轻量级的重试框架，可以通过注解或编程式的方式实现重试逻辑。

通过 `@Retryable` 注解标记需要重试的方法，并可以指定重试策略：

```java
@Service
public class PaymentService {
    @Retryable(
        include = {PaymentTimeoutException.class}, // 指定需要重试的异常类型
        maxAttempts = 2, // 最大重试次数
        backoff = @Backoff(delay = 5000) // 退避策略，延迟时间和倍数
    )
    public PaymentResult processPayment(PaymentRequest request) {
        // 支付处理逻辑
    }

    @Recover
    public PaymentResult fallbackProcessPayment(PaymentTimeoutException e) {
        // 兜底处理逻辑
    }
}
```

配置 @Retryable 注解，只对 PaymentTimeoutException 的异常进行重试，重试两次，每次延时5000ms。

Spring有哪些重试的策略。

- NeverRetryPolicy：只允许调用RetryCallback一次，不允许重试。

- AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环。

- SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略。
- ExpressionRetryPolicy： 允许使用 Spring 表达式语言（SpEL）定义自定义的重试策略。
- ExceptionClassifierRetryPolicy： 允许根据异常类型分类并应用不同的重试策略
- BinaryExceptionClassifierRetryPolicy：基于 `BinaryExceptionClassifier` 来分类异常，并决定是否重试

- TimeoutRetryPolicy：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试。
- MaxAttemptsRetryPolicy：基于固定次数进行重试的场景。

- CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate；

- CompositeRetryPolicy：组合重试策略。有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即不可以。但不管哪种组合方式，组合中的每一个策略都会执行。

关于Backoff的策略如下。

- NoBackOffPolicy：无退避算法策略，即当重试时是立即重试；

- FixedBackOffPolicy：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒。

- UniformRandomBackOffPolicy：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod。该策略在[minBackOffPeriod, maxBackOffPeriod]之间取一个随机休眠时间，minBackOffPeriod默认为500毫秒，maxBackOffPeriod默认为1500毫秒。

- ExponentialBackOffPolicy：指数退避策略，需设置参数sleeper、initialInterval、maxInterval和multiplier。initialInterval指定初始休眠时间，默认为100毫秒。maxInterval指定最大休眠时间，默认为30秒。multiplier指定乘数，即下一次休眠时间为当前休眠时间 * multiplier。

- ExponentialRandomBackOffPolicy：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致DDos，使用随机休眠时间来避免这种情况。

通过 `RetryTemplate` 实现更复杂的重试逻辑：

```java
@Configuration
public class CustomRetryConfig {
    @Bean
    public RetryTemplate retryTemplate() {
        RetryTemplate template = new RetryTemplate();

        // 设置重试策略
        SimpleRetryPolicy policy = new SimpleRetryPolicy();
        policy.setMaxAttempts(5);

        // 设置延迟策略
        ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
        backOffPolicy.setInitialInterval(1000);
        backOffPolicy.setMultiplier(2.0);

        template.setRetryPolicy(policy);
        template.setBackOffPolicy(backOffPolicy);

        return template;
    }
}
```

在业务逻辑中使用 `RetryTemplate`：

```java
@Service
public class OrderService {
    @Autowired
    private RetryTemplate retryTemplate;

    public String createOrder(CreateOrderReq req) {
        return retryTemplate.execute(context -> {
            // 尝试执行的业务逻辑
            return doCreateOrder(req);
        });
    }
}
```

这种方式提供了更灵活的重试策略配置。

## 2. 使用 Guava Retrying

Guava Retrying 是一个基于 Guava 的重试库，提供了丰富的重试策略。

```java
public class HttpService extends HttpUtil {

    private final Retryer<JSONObject> retryer = RetryerBuilder.<JSONObject>newBuilder()
            .retryIfExceptionOfType(Exception.class) // 根据异常重试
            .retryIfResult(Predicates.isNull()) // 返回结果为 null 时重试
            .withWaitStrategy(WaitStrategies.fixedWait(3, TimeUnit.SECONDS)) // 固定延迟策略
            .withStopStrategy(StopStrategies.stopAfterAttempt(3)) // 最大重试次数
            .withRetryListener(new MyRetryListener()) // 自定义重试监听器
            .build();

    @Override
    public JSONObject post(String requestUrl, String outputStr) {
        Callable<JSONObject> callable = () -> super.post(requestUrl, outputStr);
        try {
            return retryer.call(callable);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

通过 `RetryerBuilder` 构建重试器，并在 HTTP 请求方法中使用。

## 3. 使用 Resilience4j

Resilience4j 是一个轻量级的容错库，支持多种容错模式，包括重试、断路器等。

```java
@Retry(name = "inventoryService", fallbackMethod = "fallback")
public InventoryResponse deductStock(InventoryRequest request) {
    // 库存扣减逻辑
}
```

**Resilience4j 可以同时实现重试、限流、熔断和降级。**

```java
@Service
public class CompositeService {
    @Retryable(value = {Exception.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    @CircuitBreaker(name = "exampleCircuitBreaker", fallbackMethod = "fallback")
    @RateLimiter(name = "exampleRateLimiter", fallbackMethod = "fallback")
    public String fetchData() {
        // 模拟可能失败的操作
        throw new RuntimeException("Transient error");
    }

    public String fallback(Exception e) {
        return "Composite fallback response";
    }
}
```



## 4. 使用 Hystrix

Hystrix 是 Netflix 开发的容错库，支持断路器和重试机制。

```java
@HystrixCommand(
    commandProperties = {
        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000")
    },
    threadPoolProperties = {
        @HystrixProperty(name = "coreSize", value = "20")
    })
@Retryable(maxAttempts = 3)
public ServiceResponse remoteCall() {
    // 远程调用逻辑
}
```

结合 Hystrix 的断路器和重试机制，提高系统的容错能力。

## 5. 使用 Feign Client 重试

### 通过配置 `Retryer` 来实现重试逻辑

在使用 Feign 客户端时，可以通过配置 `Retryer` 来实现重试逻辑。

```java
@Configuration
public class FeignConfig {

    @Bean
    public Retryer feignRetryer() {
        return new Retryer.Default(100, 1000, 3);
    }
}
```

### 根据 HTTP 响应的 JSON 内容实现重试

要实现 Feign 客户端根据 HTTP 响应的 JSON 内容（如 `code` 字段）来判断是否需要重试，可以通过自定义 `ErrorDecoder` 和 `Retryer` 来实现。

```java
public class CustomErrorDecoder implements ErrorDecoder {
    private final ErrorDecoder defaultErrorDecoder = new Default();

    @Override
    public Exception decode(String methodKey, Response response) {
        // 调用默认的 ErrorDecoder 处理非 2xx 响应
        if (response.status() >= 400 && response.status() < 600) {
            return defaultErrorDecoder.decode(methodKey, response);
        }

        // 解析响应体中的 JSON 数据
        try {
            String body = new String(response.body().asInputStream(), StandardCharsets.UTF_8);
            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode jsonNode = objectMapper.readTree(body);

            // 检查 code 字段
            int code = jsonNode.get("code").asInt();
            if (code != 0) {
                // 如果 code 不为 0，抛出自定义异常
                return new CustomFeignException("Request failed with code: " + code);
            }
        } catch (IOException e) {
            // 如果解析失败，抛出异常
            return new RuntimeException("Failed to parse response body", e);
        }

        // 如果 code 为 0，不抛出异常
        return null;
    }
}

public class CustomFeignException extends RuntimeException {
    public CustomFeignException(String message) {
        super(message);
    }
}

@Configuration
public class FeignConfig {
    @Bean
    public ErrorDecoder feignErrorDecoder() {
        return new CustomErrorDecoder();
    }

    @Bean
    public Retryer feignRetryer() {
        return new Retryer.Default(100, 1000, 3); // 初始间隔100ms，最大间隔1000ms，重试3次
    }
}
```

### 动态判断服务器性能指标决定是否测试

```java
@Slf4j
public class DynamicRetryer implements Retryer {
    private final int maxAttempts;
    private final long period;
    private final long maxPeriod;
    private int attempt;
    private long sleptForMillis;

    public DynamicRetryer(long period, long maxPeriod, int maxAttempts) {
        this.period = period;
        this.maxPeriod = maxPeriod;
        this.maxAttempts = maxAttempts;
        this.attempt = 1;
    }

    @Override
    public void continueOrPropagate(RetryableException e) {
        if (attempt++ >= maxAttempts) {
            throw e;
        }

        // 检查当前服务的性能指标
        if (shouldRetry()) {
            long interval = nextMaxInterval();
            try {
                Thread.sleep(interval);
            } catch (InterruptedException ignored) {
                Thread.currentThread().interrupt();
                throw e;
            }
            sleptForMillis += interval;
            log.info("错误内容getMessage：{}，重试次数：{}，重试时间间隔ms：{}", e.getCause().getMessage(), attempt, interval);
        } else {
            log.info("达到性能指标上限，不再重试");
            throw e;
        }
    }

    private boolean shouldRetry() {
        // 获取当前服务的 CPU 使用率和线程数
        double cpuUsage = getCurrentCpuUsage();
        int threadCount = getCurrentThreadCount();

        // 根据性能指标决定是否重试
        // 例如：CPU 使用率低于 80% 且线程数低于 100 时继续重试
        return cpuUsage < 0.8 && threadCount < 100;
    }

    private double getCurrentCpuUsage() {
        // 实现获取当前服务的 CPU 使用率逻辑
        return 0.75; // 示例值
    }

    private int getCurrentThreadCount() {
        // 实现获取当前服务的线程数逻辑
        return 50; // 示例值
    }

    private long nextMaxInterval() {
        long interval = (long) (period * Math.pow(1.5, attempt - 1));
        return interval > maxPeriod ? maxPeriod : interval;
    }

    @Override
    public DynamicRetryer clone() {
        return new DynamicRetryer(period, maxPeriod, maxAttempts);
    }
}
```

