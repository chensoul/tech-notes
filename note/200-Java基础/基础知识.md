## == 和 equals 有什么区别？

对于 Object 来说，== 和 equals 都是一样的，都是用来对比两个对象的引用是否相同的，而其他 Java 中的类中，如 String 或 Integer 等，通常都会重写 equals 让其变为比较具体的值是否相同，而非引用是否相同。 所以，我们通常会使用 == 来对比两个对象的引用是否相同，而使用 equals 对比两个值是否相同（前提条件是重写了 equals 方法）。

## finally 中的代码一定会被执行吗？

正常运行的情况下，finally 中的代码是一定会执行的，但是，如果遇到以下异常情况，那么 finally 中的代码就不会继续执行了：

1. 程序在 try 块中遇到 System.exit() 方法，会立即终止程序的执行
2. 在 try 快中遇到 Runtime.getRuntime().halt() 代码，强制终止正在运行的 JVM。与 System.exit()方法不同，此方法不会触发 JVM 关闭序列。因此，当我们调用 halt 方法时，都不会执行关闭钩子或终结器。
3. 程序在 try 块中遇到无限循环或者发生死锁等情况时，程序可能无法正常跳出 try 块，此时 finally 块中的代码也不会被执行。
4. 掉电问题，程序还没有执行到 finally 就掉电了（停电了），那 finally 中的代码自然也不会执行。
5. JVM 异常崩溃问题导致程序不能继续执行，那么 finally 的代码也不会执行。

## 深克隆和浅克隆

在编程中，克隆是指创建一个与原始对象相同的新对象。这个新对象通常具有与原始对象相同的属性和方法，但是它们是两个不同的对象，它们在内存中的位置不同。 在 Java 中，可以通过实现 Cloneable 接口和重写 clone() 方法来实现对象的克隆。

- 浅克隆：克隆出来的新对象与原始对象共享引用类型的属性。也就是说，新对象中的引用类型属性指向的是原始对象中相同的引用类型属性。如果修改了新对象中的引用类型属性，原始对象中的相应属性也会被修改。在 Java 中，可以通过实现 Cloneable 接口和重写 clone() 方法来实现浅克隆。
- 深克隆：克隆出来的新对象与原始对象不共享引用类型的属性。也就是说，新对象中的引用类型属性指向的是新的对象，而不是原始对象中相同的引用类型属性。如果修改了新对象中的引用类型属性，原始对象中的相应属性不会被修改。

深克隆的实现方法有很多，比如以下几个：

1. 所有引用属性都实现克隆，整个对象就变成了深克隆。
2. 使用 JDK 自带的字节流序列化和反序列化对象实现深克隆。
3. 使用第三方工具实现深克隆，比如 Apache Commons Lang。
4. 使用 JSON 工具，如 GSON、FastJSON、Jackson 序列化和反序列化对象实现深克隆。

## Java 是值传递还是引用传递？

这是 Java 中比较基础的一道常见面试题，但**对于这道问题的大部分答案都是错的**，大部人会这样回答这个问题：

> 在 Java 中，如果传递的是基本数据类型，那么就是值传递；而如果传递的是对象或数组的话，那么就是引用传递。

然而，**这个答案是错的！**

**在 Java 中，（传递参数时）无论是基本数据类型还是对象（或数组），使用的都是值传递的方式**。只是对于对象（或数组）而言，传递的值是对象引用副本，而非对象引用本身。

> **在 Java 中，只有值传递没有引用传递**。



## 重载

### 什么是方法重载？

在 Java 中，方法重载是指在同一个类中定义多个方法，它们具有相同的名称但参数列表不同。

### 重载和重写的区别

重载（Overloading）

- **定义**：重载是指在同一个类中，可以有多个同名的方法，但它们的参数列表必须不同。
- **作用范围**：同一个类。
- **参数列表**：参数类型、参数个数或参数顺序必须不同。
- **返回类型**：可以相同，也可以不同。
- **访问修饰符**：可以相同，也可以不同。
- **异常声明**：可以相同，也可以不同。

重写（Overriding）

- **定义**：重写是指在子类中重新定义父类的方法，以提供特定的实现。
- **作用范围**：父类和子类之间。
- **方法签名**：方法名、参数列表和返回类型必须与父类的方法完全相同。
- **访问修饰符**：子类方法的访问修饰符不能比父类方法的访问修饰符更严格。
- **异常声明**：子类方法可以抛出更少或更具体的异常，但不能抛出更多的异常。

## 多态

多态是面向对象编程中的一个重要概念，它允许通过父类类型的引用变量来引用子类对象，并在运行时根据实际对象的类型来确定调用哪个方法。换句话说，一个对象可以根据不同的情况表现出多种形态。

通过多态，我们可以利用父类类型的引用变量来指向子类对象，并根据实际对象的类型调用对应的方法。这样可以在不修改现有代码的情况下，动态地切换和扩展对象的行为。

多态有以下几个特点和优势：

1. **可替换性**：子类对象可以随时替代父类对象，向上转型。
2. **可扩展性**：通过添加新的子类，可以扩展系统的功能。
3. **接口统一性**：可以通过父类类型的引用访问子类对象的方法，统一对象的接口。
4. **代码的灵活性和可维护性**：通过多态，可以将代码编写成通用的、松耦合的形式，提高代码的可维护性。

要了解多态的实现原理，需要先了解两个概念：动态绑定和虚拟方法调用。

- 动态绑定（Dynamic Binding）：指的是在编译时，Java 编译器只能知道变量的声明类型，而无法确定其实际的对象类型。而在运行时，Java 虚拟机（JVM）会通过动态绑定来解析实际对象的类型。这意味着，编译器会推迟方法的绑定（即方法的具体调用）到运行时。正是这种动态绑定机制，使得多态成为可能。
- 虚拟方法调用（Virtual Method Invocation）：在 Java 中，所有的非私有、非静态和非 final 方法都是被隐式地指定为虚拟方法。虚拟方法调用是在运行时根据实际对象的类型来确定要调用的方法的机制。当通过父类类型的引用变量调用被子类重写的方法时，虚拟机会根据实际对象的类型来确定要调用的方法版本，而不是根据引用变量的声明类型。

多态的实现原理主要是依靠“动态绑定”和“虚拟方法调用”，它的实现流程如下：

1. 创建父类类型的引用变量，并将其赋值为子类对象。
2. 在运行时，通过动态绑定确定引用变量所指向的实际对象的类型。
3. 根据实际对象的类型，调用相应的方法版本。

## 抽象

在 Java 中，普通类和抽象类是两种不同的类类型。普通类是可以直接实例化的类，而抽象类则不能直接实例化。抽象类通常用于定义一些基本的行为和属性，而具体的实现则由其子类来完成。以下是普通类和抽象类的一些区别：

1. 实例化：普通类可以直接实例化，而抽象类不能直接实例化。
2. 方法：抽象类中既包含抽象方法又可以包含具体的方法，而普通类只能包含普通方法。
3. 实现：普通类实现接口需要重写接口中的方法，而抽象类可以实现接口方法也可以不实现。

## 反射

在 Java 中，反射是指在**运行时检查和操作**类、接口、字段、方法等程序结构的能力。通过反射，可以在运行时获取类的信息，创建类的实例，调用类的方法，访问和修改类的字段等。

反射在日常开发中使用的地方有很多，例如以下几个：

1. **动态代理**：反射是动态代理的底层实现，即在运行时动态地创建代理对象，并拦截和增强方法调用。这常用于实现 AOP 功能，如日志记录、事务管理等。

2. **Bean 创建**：Spring/Spring Boot 项目中，在项目启动时，创建的 Bean 对象就是通过反射来实现的。

3. **JDBC 连接**：JDBC 中的 DriverManager 类通过反射加载并注册数据库驱动，这是 Java 数据库连接的标准做法。

   

反射的关键实现方法有以下几个：

1. **得到类**：Class.forName("类名")
2. **得到所有字段**：clazz.getDeclaredFields()
3. **得到所有方法**：clazz.getDeclaredMethods()
4. **得到构造方法**：clazz.getDeclaredConstructor()
5. **得到实例**：clazz.getDeclaredConstructor().newInstance()
6. **调用方法**：method.invoke()

对于反射来说，操纵类最主要的方法是 invoke，所以搞懂了 invoke 方法的实现，也就搞定了反射的底层实现原理了。

invoke 方法的执行流程如下：

1. **查找方法**：当通过 java.lang.reflect.Method 对象调用 invoke 方法时，Java 虚拟机（JVM）首先确认该方法是否存在并可以访问。这包括检查方法的访问权限、方法签名是否匹配等。
2. **安全检查**：如果方法是私有的或受保护的，还需要进行访问权限的安全检查。如果当前调用者没有足够的权限访问这个方法，将抛出 IllegalAccessException。
3. **参数转换和适配**：invoke 方法接受一个对象实例和一组参数，需要将这些参数转换成对应方法签名所需要的类型，并且进行必要的类型检查和装箱拆箱操作。
4. **方法调用**：对于非私有方法，Java 反射实际上是通过 JNI（Java Native Interface，Java 本地接口）调用到 JVM 内部的 native 方法，例如 java.lang.reflect.Method.invoke0()。这个 native 方法负责完成真正的动态方法调用。对于 Java 方法，JVM 会通过方法表、虚方法表（vtable）进行查找和调用；对于非虚方法或者静态方法，JVM 会直接调用相应的方法实现。
5. **异常处理**：在执行方法的过程中，如果出现任何异常，JVM 会捕获并将异常包装成 InvocationTargetException 抛出，应用程序可以通过这个异常获取到原始异常信息。
6. **返回结果**：如果方法正常执行完毕，invoke 方法会返回方法的执行结果，或者如果方法返回类型是 void，则不返回任何值。

通过这种方式，Java 反射的 invoke 方法能够打破编译时的绑定，实现运行时动态调用对象的方法，提供了极大的灵活性，但也带来了运行时性能损耗和安全隐患（如破坏封装性、违反访问控制等）。

反射的优点如下：

1. 灵活性：使用反射可以在运行时动态加载类，而不需要在编译时就将类加载到程序中。这对于需要动态扩展程序功能的情况非常有用。
2. 可扩展性：使用反射可以使程序更加灵活和可扩展，同时也可以提高程序的可维护性和可测试性。
3. 实现更多功能：许多框架都使用反射来实现自动化配置和依赖注入等功能。例如，Spring 框架就使用反射来实现依赖注入。

反射的缺点如下：

1. 性能问题：使用反射会带来一定的性能问题，因为反射需要在运行时动态获取类的信息，这比在编译时就获取信息要慢。
2. 安全问题：使用反射可以访问和修改类的字段和方法，这可能会导致安全问题。因此，在使用反射时需要格外小心，确保不会对程序的安全性造成影响。