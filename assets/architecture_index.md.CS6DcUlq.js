import{_ as a,o as r,c as t,ae as i}from"./chunks/framework.gns6yynO.js";const s="/tech-notes/assets/image-20241101074825888.i2_5Ueo7.png",n="/tech-notes/assets/image-20241101074124360.hh9s-_mj.png",l="/tech-notes/assets/image-20241101074146948.CVOOz3F2.png",o="/tech-notes/assets/image-20241101074212749.BhIPpjWf.png",h="/tech-notes/assets/image-20241101074303978.DgezTJMb.png",p="/tech-notes/assets/image-20241101074446536.BoVzx2aA.png",c="/tech-notes/assets/image-20241101074503154.CbRq7E2G.png",g="/tech-notes/assets/image-20241101074519368.DCFOkW7h.png",d="/tech-notes/assets/image-20241101074636550.BNAUk7Q-.png",m="/tech-notes/assets/image-20241101074704720.CwMZ1Dg7.png",_=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"architecture/index.md","filePath":"architecture/index.md"}'),u={name:"architecture/index.md"};function k(b,e,f,E,y,w){return r(),t("div",null,[...e[0]||(e[0]=[i('<h2 id="架构发展历程" tabindex="-1">架构发展历程 <a class="header-anchor" href="#架构发展历程" aria-label="Permalink to &quot;架构发展历程&quot;">​</a></h2><p>参考 <a href="https://www.jianshu.com/p/b477b2cc6cfa" target="_blank" rel="noreferrer">1.软件架构编年史(译)</a>，架构发展经历以下几个阶段：</p><ul><li><strong>过程式/函数式编程</strong></li><li><strong>MVC 模式(Model-View-Controller)</strong></li><li><strong>面向对象编程</strong></li><li><strong>CORBA</strong></li><li><strong>Message Bus</strong></li><li><strong>EBI 架构</strong>(Entity-Boundary-Interactor)</li><li><strong>面向方面编程</strong></li><li><strong>Web Services</strong></li><li><strong>ESB</strong></li><li><strong>DDD</strong></li><li><strong>MVVM 模式</strong></li><li><strong>端口和适配器架构</strong>，即六边形架构</li><li><strong>洋葱架构</strong></li><li><strong>微服务</strong></li><li><strong>DCI 架构</strong>(Data-Context-Interaction)</li><li><strong>整洁架构</strong></li><li><strong>C4 模型</strong></li></ul><h2 id="分层架构" tabindex="-1">分层架构 <a class="header-anchor" href="#分层架构" aria-label="Permalink to &quot;分层架构&quot;">​</a></h2><img src="https://upload-images.jianshu.io/upload_images/4099-86a57eb27ad63a8c.png" alt="img" style="zoom:50%;"><img src="https://upload-images.jianshu.io/upload_images/4099-3b29f804f28fadda.png" alt="img" style="zoom:50%;"><img src="https://upload-images.jianshu.io/upload_images/4099-adb2a8a51accd1aa.png" alt="img" style="zoom:50%;"><img src="https://upload-images.jianshu.io/upload_images/4099-737b9f8d0cdccee9.png" alt="img" style="zoom:50%;"><img src="https://www.happycoders.eu/wp-content/uploads/2023/06/hexagonal-architecture-java.v4-800x601.png" alt="Hexagonal architecture of the sample application" style="zoom:50%;"><img src="https://stibel.icu/_images/method/arch-principle/%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84.png" alt="洋葱架构" style="zoom:50%;"><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="img" style="zoom:50%;"><h2 id="单体架构和微服务" tabindex="-1">单体架构和微服务 <a class="header-anchor" href="#单体架构和微服务" aria-label="Permalink to &quot;单体架构和微服务&quot;">​</a></h2><blockquote><p><a href="https://www.youtube.com/watch?v=430YOyMNjhs&amp;t=565s" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=430YOyMNjhs&amp;t=565s</a></p></blockquote><img src="'+s+'" alt="image-20241101074825888" style="zoom:50%;"><p>单体架构：应用打包多个边界上下文到一个部署单元。所有应用代码被部署并<em>运行在单一节点的单一进程中</em>。</p><ul><li>容易重构</li><li>容易测试整个系统</li><li>除非明确管理，否则可能会降级</li><li>更难测试单个限界上下文</li></ul><p>微服务：上下文的有界上下文定义了部署构件的边界。某些部分甚至被部署为单独的进程。</p><ul><li><p>有界上下文交互是远程的</p></li><li><p>测试单个模块</p></li><li><p>难以重构上下文边界</p></li><li><p>很难对整个系统进行测试</p></li></ul><h2 id="包和命名空间" tabindex="-1">包和命名空间 <a class="header-anchor" href="#包和命名空间" aria-label="Permalink to &quot;包和命名空间&quot;">​</a></h2><p><strong>包内聚原则</strong></p><ul><li><strong>REP</strong> – <a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOGM2ZGFhNmYtNmE4ZS00OGY5LWFkZTYtMjE0ZGNjODQ0MjEx&amp;hl=en" target="_blank" rel="noreferrer">重用发布等价原则</a><em>重用的粒度等价于发布的粒度</em></li><li><strong>CCP</strong> – <a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOGM2ZGFhNmYtNmE4ZS00OGY5LWFkZTYtMjE0ZGNjODQ0MjEx&amp;hl=en" target="_blank" rel="noreferrer">共同封闭原则</a><em>一起被修改的类应该放在一个包里</em></li><li><strong>CRP</strong> – <a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOGM2ZGFhNmYtNmE4ZS00OGY5LWFkZTYtMjE0ZGNjODQ0MjEx&amp;hl=en" target="_blank" rel="noreferrer">共同重用原则</a><em>一起被重用的类应该放在一个包里</em></li></ul><p><strong>包耦合原则</strong></p><ul><li><strong>ADP</strong> – <a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOGM2ZGFhNmYtNmE4ZS00OGY5LWFkZTYtMjE0ZGNjODQ0MjEx&amp;hl=en" target="_blank" rel="noreferrer">无环依赖原则</a><em>包的依赖图中不能出现循环</em></li><li><strong>SDP</strong> – <a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgZjI3OTU4ZTAtYmM4Mi00MWMyLTgxN2YtMzk5YTY1NTViNTBh&amp;hl=en" target="_blank" rel="noreferrer">稳定依赖原则</a><em>依赖应该朝着稳定的方向前进</em></li><li><strong>SAP</strong> – <a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgZjI3OTU4ZTAtYmM4Mi00MWMyLTgxN2YtMzk5YTY1NTViNTBh&amp;hl=en" target="_blank" rel="noreferrer">稳定抽象原则</a><em>抽象的级别越高，稳定性就越高</em></li></ul><p>包的分层：</p><ul><li>按照层打包</li><li>按照功能打包</li></ul><h2 id="spring-modulith" tabindex="-1">Spring Modulith <a class="header-anchor" href="#spring-modulith" aria-label="Permalink to &quot;Spring Modulith&quot;">​</a></h2><blockquote><p><a href="https://www.youtube.com/watch?v=hLa0SOVN6xQ&amp;t=138s" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=hLa0SOVN6xQ&amp;t=138s</a></p></blockquote><img src="'+n+'" alt="image-20241101074124360" style="zoom:50%;"><img src="'+l+'" alt="image-20241101074146948" style="zoom:50%;"><img src="'+o+'" alt="image-20241101074212749" style="zoom:50%;"><img src="'+h+'" alt="image-20241101074303978" style="zoom:50%;"><img src="'+p+'" alt="image-20241101074446536" style="zoom:67%;"><img src="'+c+'" alt="image-20241101074503154" style="zoom:67%;"><img src="'+g+'" alt="image-20241101074519368" style="zoom:67%;"><img src="'+d+'" alt="image-20241101074636550" style="zoom:67%;"><img src="'+m+`" alt="image-20241101074704720" style="zoom:50%;"><p>基础概念：</p><p>1、<strong>应用程序模块</strong></p><p>在 Spring Boot 应用程序中，应用程序模块是一个功能单元，是一个包，它由以下部分组成：</p><ul><li>向 Spring Bean 实例实现的其他模块和模块发布的应用程序事件公开的 API，通常称为<em>提供的接口</em>。</li><li>不应被其他模块访问的内部实现组件。</li><li>对其他模块以 Spring bean 依赖项、侦听的应用程序事件和公开的配置属性的形式公开的 API 的引用，通常称为<em>必需接口</em>。</li></ul><p>应用程序的<em>主包</em>是主应用程序类（@SpringBootApplicatio）所在的包，默认情况下，主包的每个直接子包都被视为<em>一个应用程序模块包</em>。</p><p>2、<strong>简单的应用程序模块</strong>：不包含任何子包，该包下可以有 public、private 的类。</p><p>3、<strong>高级应用程序模块</strong>：包含子包的应用程序模块。子包中的 internal 包为内部子包，其中的代码不得从其他模块引用。</p><p>4、<strong>嵌套应用程序模块</strong>：在高级应用模块的子包中可以包含子包，并在 package-info.java 中添加 @ApplicationModule 注解。</p><ul><li>嵌套模块中的代码可以被父包或者兄弟模块访问</li><li><em>嵌套</em>模块中的任何代码都可以访问父模块中的代码，甚至是内部代码</li><li>嵌套模块中的代码也可以访问顶级应用程序模块公开的类型</li></ul><p>5、<strong>开放应用模块</strong>：@ApplicationModule 标准的模块默认是封闭的，只能访问其他模块的公开类型。可以在该注解上添加 type = Type.OPEN 将其变为开放的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">org.springframework.modulith.ApplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Type.OPEN</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example.inventory;</span></span></code></pre></div><p>6、<strong>显式应用程序模块依赖关系</strong>：模块可以选择使用<code>@ApplicationModule</code>软件包上的注释来声明其允许的依赖项</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">org.springframework.modulith.ApplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  allowedDependencies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;order&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example.inventory;</span></span></code></pre></div><p>7、<strong>命名接口</strong>：可以给子包添加命名接口，让后允许其他模块访问</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">org.springframework.modulith.NamedInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;spi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example.order.spi;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">org.springframework.modulith.ApplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  allowedDependencies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;order :: spi&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example.inventory;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// or</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">org.springframework.modulith.ApplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  allowedDependencies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;order :: *&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example.inventory;</span></span></code></pre></div><p><strong>自定义模块检测</strong>:</p><ul><li>在启动类上使用 @Modulithic 注解的 additionalPackages 属性，添加其他包作为根应用程序包</li><li>使用配置：<code>spring.modulith.detection-strategy=explicitly-annotated</code>，仅考虑使用了注解的包</li><li>使用自定义的策略：<code>spring.modulith.detection-strategy=example.CustomApplicationModuleDetectionStrategy</code></li><li>通过 spring.factories 文件：<code>org.springframework.modulith.core.ApplicationModuleSourceFactory=example.CustomApplicationModuleSourceFactory</code></li></ul><p>spring modulith 示例代码：</p><ul><li><a href="https://github.com/odrotbohm/arch-evident-spring" target="_blank" rel="noreferrer">https://github.com/odrotbohm/arch-evident-spring</a></li><li><a href="https://github.com/odrotbohm/spring-modulith-deep-dive/" target="_blank" rel="noreferrer">https://github.com/odrotbohm/spring-modulith-deep-dive/</a></li><li><a href="https://github.com/vicziani/jtechlog-spring-modulith" target="_blank" rel="noreferrer">https://github.com/vicziani/jtechlog-spring-modulith</a></li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><h3 id="software-architecture" tabindex="-1">Software Architecture <a class="header-anchor" href="#software-architecture" aria-label="Permalink to &quot;Software Architecture&quot;">​</a></h3><ul><li><a href="https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/" target="_blank" rel="noreferrer">The Software Architecture Chronicles</a></li><li><a href="https://alistair.cockburn.us/hexagonal-architecture/" target="_blank" rel="noreferrer">Hexagonal architecture by Alistair Cockburn</a></li><li><a href="https://www.happycoders.eu/software-craftsmanship/hexagonal-architecture/" target="_blank" rel="noreferrer">Hexagonal Architecture - What Is It? Why Should You Use It?</a></li><li><a href="https://www.happycoders.eu/software-craftsmanship/hexagonal-architecture-spring-boot/" target="_blank" rel="noreferrer">Hexagonal Architecture with Spring Boot</a></li><li><a href="https://herbertograca.com/2017/08/03/layered-architecture/" target="_blank" rel="noreferrer">Layered Architecture</a></li><li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noreferrer">The Clean Architecture by Uncle Bob</a></li><li><a href="https://scalastic.io/en/hexagonal-architecture/" target="_blank" rel="noreferrer">Everything You Need to Know About Hexagonal Architecture: Kernel, Ports, Adapters</a></li><li><a href="https://www.amazon.in/Your-Hands-Dirty-Clean-Architecture/dp/180512837X/" target="_blank" rel="noreferrer">Get Your Hands Dirty on Clean Architecture</a></li><li><a href="https://victorrentea.ro/blog/overengineering-in-onion-hexagonal-architectures/" target="_blank" rel="noreferrer">Overengineering in Onion/Hexagonal Architectures</a></li><li><a href="https://www.vinsguru.com/cqrs-pattern/" target="_blank" rel="noreferrer">CQRS Pattern With Spring Boot</a></li><li><a href="https://www.youtube.com/watch?v=Lw04HRF8ies" target="_blank" rel="noreferrer">CQRS pitfalls and patterns</a></li><li><a href="https://www.youtube.com/watch?v=LDW0QWie21s" target="_blank" rel="noreferrer">Greg Young — A Decade of DDD, CQRS, Event Sourcing</a></li><li><a href="https://www.youtube.com/watch?v=5OjqD-ow8GE" target="_blank" rel="noreferrer">Modular Monoliths • Simon Brown</a></li><li><a href="https://www.youtube.com/watch?v=jzp0PGVegHA" target="_blank" rel="noreferrer">Five things every developer should know about software architecture by Simon Brown</a></li><li><a href="https://phauer.com/2020/package-by-feature/" target="_blank" rel="noreferrer">Package by Layer vs Feature</a></li></ul><h3 id="domain-driven-design" tabindex="-1">Domain Driven Design <a class="header-anchor" href="#domain-driven-design" aria-label="Permalink to &quot;Domain Driven Design&quot;">​</a></h3><ul><li><a href="https://www.amazon.in/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" target="_blank" rel="noreferrer">Domain-Driven Design: Tackling Complexity in the Heart of Software</a></li><li><a href="https://www.amazon.in/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577" target="_blank" rel="noreferrer">Implementing Domain-Driven Design</a></li><li><a href="https://medium.com/ssense-tech/domain-driven-design-everything-you-always-wanted-to-know-about-it-but-were-afraid-to-ask-a85e7b74497a" target="_blank" rel="noreferrer">Domain-Driven Design: Everything You Always Wanted to Know About it, But Were Afraid to Ask</a></li><li><a href="https://vaadin.com/blog/ddd-part-1-strategic-domain-driven-design" target="_blank" rel="noreferrer">DDD Part 1: Strategic Domain-Driven Design</a></li><li><a href="https://github.com/ddd-crew" target="_blank" rel="noreferrer">Domain-Driven Design Crew</a></li></ul><h3 id="documenting-architecture" tabindex="-1">Documenting Architecture <a class="header-anchor" href="#documenting-architecture" aria-label="Permalink to &quot;Documenting Architecture&quot;">​</a></h3><ul><li><a href="https://adr.github.io/" target="_blank" rel="noreferrer">Architectural Decision Records (ADRs)</a></li><li><a href="https://c4model.com/" target="_blank" rel="noreferrer">The C4 model for visualising software architecture</a></li></ul><h3 id="enforcing-coding-architecture-guidelines" tabindex="-1">Enforcing Coding &amp; Architecture Guidelines <a class="header-anchor" href="#enforcing-coding-architecture-guidelines" aria-label="Permalink to &quot;Enforcing Coding &amp; Architecture Guidelines&quot;">​</a></h3><ul><li>Coding Standards and Bug Pattern Detectors <ul><li><a href="https://checkstyle.sourceforge.io/" target="_blank" rel="noreferrer">CheckStyle</a></li><li><a href="https://pmd.github.io/" target="_blank" rel="noreferrer">PMD</a>, <a href="https://spotbugs.github.io/" target="_blank" rel="noreferrer">SpotBugs</a></li><li><a href="https://github.com/google/error-prone" target="_blank" rel="noreferrer">ErrorProne</a></li><li><a href="https://www.sonarsource.com/products/sonarqube/" target="_blank" rel="noreferrer">SonarQube</a></li></ul></li><li><a href="https://www.archunit.org/" target="_blank" rel="noreferrer">ArchUnit</a> - Enforce architecture guidelines as tests</li><li><a href="https://spring.io/projects/spring-modulith" target="_blank" rel="noreferrer">Spring Modulith</a> - Enforce modularity in Modular Monoliths</li></ul><h3 id="reference-implementations" tabindex="-1">Reference Implementations <a class="header-anchor" href="#reference-implementations" aria-label="Permalink to &quot;Reference Implementations&quot;">​</a></h3><ul><li><a href="https://github.com/hirannor/springboot-hexagonal-ddd" target="_blank" rel="noreferrer">Spring-Boot application based on hexagonal architecture and DDD</a></li><li><a href="https://github.com/jesperancinha/favourite-lyrics-app" target="_blank" rel="noreferrer">Hexagonal Architecture (Kotlin)</a></li><li><a href="https://github.com/anton-liauchuk/educational-platform" target="_blank" rel="noreferrer">Modular Monolith Java application with DDD</a></li><li><a href="https://github.com/sivaprasadreddy/spring-realworld-conduit-api" target="_blank" rel="noreferrer">Spring RealWorld Conduit API</a></li><li><a href="https://github.com/rkudryashov/event-driven-architecture" target="_blank" rel="noreferrer">Event-driven architecture (Transactional outbox, Inbox, and Saga patterns)</a></li><li><a href="https://github.com/naspredam/rest-spring-boot-hexagonal-architecture" target="_blank" rel="noreferrer">Spring Boot Hexagonal Architecture</a></li><li><a href="https://github.com/spember/spring-shoestore" target="_blank" rel="noreferrer">Clean Architecture in Spring</a></li><li><a href="https://github.com/xsreality/spring-modulith-with-ddd" target="_blank" rel="noreferrer">Modular Monolith Applications with Spring Modulith and Domain Driven Design</a></li><li><a href="https://github.com/asc-lab/java-cqrs-intro" target="_blank" rel="noreferrer">CQRS with Event Sourcing</a></li><li><a href="https://github.com/sivaprasadreddy/spring-boot-microservices-course" target="_blank" rel="noreferrer">Spring Boot Microservices Application</a></li><li><a href="https://github.com/sivaprasadreddy/sivalabs-youtube-code-samples/tree/main/spring-boot-modulith-demo" target="_blank" rel="noreferrer">Spring Boot using Spring Modulith</a></li></ul>`,66)])])}const D=a(u,[["render",k]]);export{_ as __pageData,D as default};
