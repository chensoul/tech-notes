## jdk、jre 及 jvm 关系

1. JDK（Java Development Kit）

- **定义**：JDK 是 Java 开发工具包的简称，它是一个完整的 Java 开发环境，主要包括编译器、调试器、JRE 等工具。JDK 允许开发人员编写、编译和调试 Java 程序。
- **作用**：
  - 提供了 Java 编译器（`javac`），用于将 Java 源代码（`.java` 文件）编译成 Java 字节码（`.class` 文件）。
  - 提供了 Java 调试器（`jdb`）和其他开发工具，帮助开发人员调试和优化 Java 程序。
  - 包含了 Java 所需要的 API 类库，这些类库是 Java 开发的基础，提供了各种功能，如输入输出、网络通信、图形界面等。
- **关系**：JDK 包含了 JRE，因此安装了 JDK 就相当于安装了 JRE，但 JRE 中不包含开发工具。

2. JRE（Java Runtime Environment）

- **定义**：JRE 是 Java 运行时环境的简称，它是运行 Java 程序所必需的环境。JRE 包括 Java 虚拟机（JVM）和 Java 核心类库。
- **作用**：
  - 提供了 Java 虚拟机（JVM），它是运行 Java 字节码的核心组件。
  - 包含了 Java 核心类库，这些类库提供了 Java 程序运行所需的 API。
- **关系**：JRE 是运行 Java 程序的最小需求，它不包含开发工具，如 Java 编译器和调试器。JRE 包含在 JDK 中，也可以单独安装。

3. JVM（Java Virtual Machine）

- **定义**：JVM 是 Java 虚拟机的简称，它是 Java 技术的核心。JVM 是一个虚拟的计算机，它能够解释和执行 Java 字节码。
- **作用**：
  - 提供了 Java 程序运行的环境，包括内存管理、垃圾回收、线程管理等功能。
  - 实现了 Java 的跨平台特性，使得 Java 程序可以在不同的操作系统上运行，而无需重新编译。
  - 包含了类加载器（ClassLoader），它负责加载 Java 类文件。
- **关系**：JVM 是 JRE 的核心组件，JRE 包含了 JVM 和 Java 核心类库。JVM 是独立于操作系统的，它通过 JIT 编译器等技术，将 Java 字节码转换为本地机器码，以提高程序的执行效率。

JDK、JRE 和 JVM 之间的关系可以用以下公式表示：

- JDK = JRE + 开发工具（如 `javac`、`jdb` 等）
- JRE = JVM + Java 核心类库
- JVM 是 Java 程序运行的核心组件，它实现了 Java 的跨平台特性。

简单来说，JDK 是用于开发 Java 程序的工具包，JRE 是运行 Java 程序的环境，而 JVM 是运行 Java 程序的核心引擎。

## 类加载机制是什么

类加载机制分为以下三个主要步骤：

1. **加载（Loading）**

- **任务**：将类的字节码文件（`.class` 文件）从磁盘或网络中加载到内存中。
- **过程**：
  - 通过类的全限定名（Fully Qualified Name）查找字节码文件。
  - 将字节码文件转换为 JVM 内部的 `Class` 对象。
- **加载器**：由类加载器（`ClassLoader`）完成。

2. **连接（Linking）**

连接阶段分为三个子步骤：

- **验证（Verification）**：

  - 确保字节码文件的正确性和安全性。

  - 检查是否符合 JVM 规范，避免恶意代码。

- **准备（Preparation）**：
  - 为类的静态变量分配内存，并设置默认初始值（如 `0`、`null` 等）。

- **解析（Resolution）**：
  - 将常量池中的符号引用（Symbolic Reference）转换为直接引用（Direct Reference）。

3. **初始化（Initialization）**

- **任务**：执行类的静态初始化代码（如静态变量赋值、静态代码块）。
- **触发条件**：
  - 创建类的实例。
  - 访问类的静态变量或静态方法。
  - 使用反射加载类。
  - 初始化子类时，父类会先被初始化。

## 类加载器有哪些

![img](https://a.perfma.net/img/281415)

类加载器是类加载机制的核心组件，负责加载类的字节码文件。JVM 提供了以下类加载器：

**Bootstrap ClassLoader（启动类加载器）**

- **职责**：加载 JVM 核心类库（如 `java.lang.*`、`java.util.*` 等）。
- **实现**：由 JVM 内部实现，通常是用 C/C++ 编写的。
- **路径**：加载 `JAVA_HOME/lib` 目录下的类。

**Extension ClassLoader（扩展类加载器）**

- **职责**：加载 Java 扩展类库（如 `javax.*` 等）。
- **实现**：由 `sun.misc.Launcher$ExtClassLoader` 实现。
- **路径**：加载 `JAVA_HOME/lib/ext` 目录下的类。

**Application ClassLoader（应用程序类加载器）**

- **职责**：加载用户类路径（Classpath）下的类。
- **实现**：由 `sun.misc.Launcher$AppClassLoader` 实现。
- **路径**：加载 `-classpath` 或 `-cp` 指定的类。

**自定义类加载器**

- **职责**：用户可以通过继承 `ClassLoader` 类，实现自定义的类加载逻辑。
- **使用场景**：热部署、模块化加载、加密类加载等。

## 双亲委派模型

双亲委派模型是类加载器的工作机制，其核心思想是：

- 当一个类加载器需要加载一个类时，首先会委托其父类加载器去加载。
- 只有在父类加载器无法加载时，才会由自己来加载。

**优点**：

- **安全性**：避免用户自定义的类覆盖 JVM 核心类。
- **避免重复加载**：确保每个类只被加载一次。

**缺点**：

- **灵活性不足**：某些场景下需要打破双亲委派模型（如 SPI 机制）。

## 如何打破双亲委派

双亲委派模型（Parent Delegation Model）是 Java 类加载器（ClassLoader）的一种工作机制。它的核心思想是：当一个类加载器需要加载一个类时，首先会委托其父类加载器去加载，只有在父类加载器无法加载时，才会由自己来加载。这种机制保证了 Java 核心类库的安全性，但也限制了某些场景下的灵活性。

在某些情况下，我们需要打破双亲委派模型，例如：

1. **热部署**：在运行时动态加载新的类或替换已有的类。
2. **模块化加载**：不同的模块可能需要加载相同类的不同版本。
3. **SPI（Service Provider Interface）机制**：Java 的 SPI 机制（如 JDBC、JNDI）需要打破双亲委派。

以下是打破双亲委派模型的几种常见方法：

1. **自定义类加载器**

通过自定义类加载器，可以打破双亲委派模型。具体做法是重写 `ClassLoader` 的 `loadClass` 方法，改变类加载的逻辑。

```java
public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        // 1. 检查类是否已经加载
        Class<?> clazz = findLoadedClass(name);
        if (clazz != null) {
            return clazz;
        }

        // 2. 自定义加载逻辑（打破双亲委派）
        if (name.startsWith("com.example")) {
            return findClass(name); // 自己加载
        }

        // 3. 其他类交给父类加载器
        return super.loadClass(name, resolve);
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // 自定义加载类的逻辑（例如从文件或网络中加载）
        byte[] classData = loadClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException(name);
        }
        return defineClass(name, classData, 0, classData.length);
    }

    private byte[] loadClassData(String name) {
        // 实现从文件或网络中加载类的字节码
        // 例如：读取 .class 文件
        return null;
    }
}
```

使用场景

- 热部署：动态加载新的类。
- 模块化加载：加载不同版本的类。

2. **线程上下文类加载器（Thread Context ClassLoader）**

Java 提供了线程上下文类加载器（`Thread Context ClassLoader`），可以通过 `Thread.currentThread().setContextClassLoader()` 设置当前线程的类加载器。SPI 机制就是通过这种方式打破双亲委派的。

```java
public class ThreadContextClassLoaderDemo {
    public static void main(String[] args) {
        // 设置线程上下文类加载器
        ClassLoader customClassLoader = new CustomClassLoader();
        Thread.currentThread().setContextClassLoader(customClassLoader);

        // 使用线程上下文类加载器加载类
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            Class<?> clazz = contextClassLoader.loadClass("com.example.MyClass");
            System.out.println("Class loaded by: " + clazz.getClassLoader());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

使用场景

- SPI 机制：例如 JDBC 驱动加载。
- 框架扩展：允许用户自定义类加载器。

3. **OSGi 模块化加载**

OSGi（Open Services Gateway initiative）是一个动态模块化系统，它通过自定义类加载器实现了模块化加载，打破了双亲委派模型。每个模块（Bundle）都有自己的类加载器，模块之间可以共享或隔离类。

核心思想

- 每个模块（Bundle）有自己的类加载器。
- 模块之间通过 `Import-Package` 和 `Export-Package` 来共享类。

使用场景

- 模块化应用：例如 Eclipse 插件系统。

4. **Java 9 模块化系统（JPMS）**

Java 9 引入了模块化系统（Java Platform Module System, JPMS），通过模块路径（module path）和类路径（classpath）的分离，打破了传统的双亲委派模型。

核心思想

- 每个模块（Module）有自己的类加载器。
- 模块之间通过 `requires` 和 `exports` 来共享类。

使用场景

- 模块化应用：例如 Spring 5 对 JPMS 的支持。

5. **Tomcat 的类加载器**

Tomcat 是一个典型的打破双亲委派模型的应用服务器。它通过自定义类加载器实现了 Web 应用的隔离。

Tomcat 类加载器层次

1. **Bootstrap ClassLoader**：加载 JVM 核心类。
2. **System ClassLoader**：加载 Tomcat 启动类。
3. **Common ClassLoader**：加载 Tomcat 和所有 Web 应用共享的类。
4. **WebApp ClassLoader**：每个 Web 应用有自己的类加载器，优先加载自己的类。

使用场景

- Web 应用隔离：每个 Web 应用可以加载自己的类，互不干扰。

6. **打破双亲委派的注意事项**

1. **安全性**：打破双亲委派可能会导致类冲突或安全问题，需要谨慎设计。
2. **性能**：自定义类加载器可能会增加类加载的开销。
3. **兼容性**：某些框架或库可能依赖于双亲委派模型，打破后可能会导致兼容性问题。

打破双亲委派模型的常见方法包括：

1. 自定义类加载器。
2. 使用线程上下文类加载器。
3. 使用 OSGi 或 Java 9 模块化系统。
4. 参考 Tomcat 的类加载器设计。

在实际开发中，需要根据具体场景选择合适的方法，并注意安全性和性能问题。

## 运行时数据

JVM运行时数据区是Java虚拟机在执行Java程序过程中管理的内存区域，它们被划分为不同的部分，每个部分都有特定的用途和生命周期。

一、方法区（Method Area）

- **作用**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- **特点**：
  - 它是各个线程共享的内存区域，包括存储类的结构信息（如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容等）。
  - 运行时常量池是方法区的一部分，是每个类或接口的常量池的运行时表示形式，用于存储编译期生成的各种字面量和符号引用。
  - 在 HotSpot 虚拟机中，方法区也被称为“永久代”（Permanent Generation），但从 JDK 8 开始，永久代已经被元空间（Metaspace）所取代，元空间使用的是本地内存而不是虚拟机内存，因此理论上其大小可以动态扩展。

二、堆（Heap）

- **作用**：几乎所有的对象实例都在这里分配内存。
- **特点**：
  - 它是 JVM 中最大的一块内存区域，也是垃圾收集器管理的主要区域，因为对象在这里的生命周期相对较长。
  - 堆被所有线程共享，是垃圾回收的主要目标区域，Java 虚拟机提供了多种垃圾回收器，如 Serial、ParNew、Parallel、CMS 和 G1 等，用于管理堆内存。
  - 在 HotSpot 虚拟机中，堆可以被细分为新生代和老年代，新生代用于存储新创建的对象，老年代用于存储经过多次垃圾回收仍然存活的对象。

三、Java 虚拟机栈（Java Virtual Machine Stacks）

- **作用**：每个线程都有一个私有的 Java 虚拟机栈，它包含线程的执行方法。
- **特点**：
  - 每个方法的执行都会创建一个栈帧，用于存储局部变量、操作数栈、方法的返回值等信息。
  - 局部变量表存储了方法的参数和局部变量，操作数栈用于存储方法执行过程中的中间结果。
  - 栈的大小可以是固定的，也可以是动态扩展的，如果线程请求的栈深度超过限制，将抛出 `StackOverflowError`。

四、本地方法栈（Native Method Stacks）

- **作用**：类似于 Java 虚拟机栈，但主要用于执行本地方法（通常是用 C 或 C++ 编写的本地代码）。
- **特点**：
  - 它与 Java 虚拟机栈类似，不同之处在于它主要支持本地方法的执行。
  - 本地方法栈的大小也是可以配置的，如果本地方法栈的深度超过限制，将抛出 `StackOverflowError`。

五、程序计数器（Program Counter Register）

- **作用**：程序计数器是一个较小的内存区域，用于记录当前线程所执行的字节码指令的地址。
- **特点**：
  - 它是线程私有的，每个线程都有自己的程序计数器。
  - 如果线程正在执行 Java 方法，程序计数器保存的是当前执行指令的地址；如果线程正在执行本地方法，程序计数器的值为 `undefined`。
  - 程序计数器是 Java 虚拟机中唯一一个不会发生 `OutOfMemoryError` 的区域。

## 栈帧结构

https://cloud.tencent.com/developer/article/2145582

![img](https://ask.qcloudimg.com/http-save/yehe-8752617/48bdb73c8ddccb7237d4344c15ff3e4e.png)

栈帧（Stack Frame）是Java虚拟机栈（Java Virtual Machine
Stack）中的基本数据结构，它描述了每个方法执行时的状态。每当一个方法被调用，Java虚拟机就会创建一个新的栈帧，用于存储局部变量、操作数栈、动态链接信息和方法出口等。一个栈帧对应一个方法的调用。

1. 局部变量表

局部变量表主要用来存储方法中的参数和局部变量。它以一个数组的形式存在，数组元素的索引代表变量的存储位置。每个局部变量占用一个或多个数组元素，具体取决于其数据类型。

例如，在Java中，一个int型局部变量占用一个数组元素，而一个long型或double型局部变量则占用两个数组元素。

2. 操作数栈

操作数栈用于保存方法执行过程中的中间结果。方法在执行时，会将局部变量表中的值加载到操作数栈中进行运算，运算结果也会暂时存储在操作数栈中。

例如，在执行加法运算时，两个操作数首先被加载到操作数栈中，然后加法指令会从栈中弹出这两个操作数进行运算，运算结果会被压回操作数栈。

3. 动态链接

动态链接是指栈帧中的一个指针，该指针指向运行时常量池中的方法引用。它用于支持Java的动态绑定特性，即在运行时确定方法的调用目标。

例如，当调用一个对象的方法时，通过动态链接可以找到该方法在运行时常量池中的具体实现。

4. 方法返回地址

方法返回地址表示当前方法执行完毕后，程序的控制权应该返回到哪个位置。在Java中，方法调用是通过栈来实现的，每个方法调用都会生成一个新的栈帧，方法返回时，虚拟机会根据返回地址将控制权返回到调用方法的位置。

5. 附加信息

JVM规范允许栈帧保存一些附加信息，如异常处理表等。异常处理表用于记录方法中可能抛出的异常以及对应的处理程序的位置。

例如，当方法中发生了异常，虚拟机会根据异常处理表中的信息找到相应的异常处理程序来处理该异常，以确保程序的正常执行。

通过这样清晰的结构划分，栈帧能够有效地支持Java虚拟机的方法调用和执行过程，保证程序的正确性和高效性。

## 堆为什么要分代设计

在 Java 虚拟机（JVM）中，堆内存被划分为不同的区域，这种分代设计主要是为了优化垃圾回收的性能。通过将对象根据其生命周期进行分类，并采取不同的回收策略，JVM 可以更高效地管理内存。以下是堆分代设计的主要原因：

**一、提高垃圾回收效率**

**新生代（Young Generation）**：

- **目标**：主要是存储新创建的对象。由于这些对象的存活时间较短，大部分对象会很快变成垃圾。JVM 的垃圾回收器可以采用更高效的方式来回收新生代中的垃圾对象。
- **垃圾回收策略**：通常使用复制算法（Copying Algorithm）。这种算法将新生代分为两个相等的区域（Eden 区、Survivor 区）。新对象在 Eden 区创建，当 Eden 区满时，进行 Minor GC。Minor GC 会清理新生代中的垃圾对象，并将存活下来的对象移动到 Survivor 区。如果一个对象在 Survivor 区中经过多次垃圾回收后仍然存活，就会被晋升到老年代。

**老年代（Old Generation）**：

- **目标**：存储经过多次 Minor GC 后仍然存活的对象，这些对象的生命周期较长。
- **垃圾回收策略**：通常采用标记-清理（Mark-Sweep）算法或标记-整理（Mark-Compact）算法。这些算法适合处理大量的长期存活对象，但成本较高，因为需要遍历整个老年代。

通过将堆分为新生代和老年代，JVM 可以更高效地回收垃圾。对于新生代中的大量短生命周期对象，Minor GC 可以快速清理；而对于老年代中的少量长生命周期对象，则可以使用更复杂的算法进行回收。

**二、适应对象的生命周期特性**

- **年轻对象**：大多数对象在创建后很快就会变为垃圾。这些对象通常存储在新生代中，通过快速的 Minor GC 来回收。
- **年老对象**：一些对象会经过多次垃圾回收后仍然存活。这些对象通常会被晋升到老年代。老年代中的对象存活时间较长，垃圾回收的频率相对较低。

**三、优化内存分配和回收**

- **内存分配**：新生代中的 Eden 区是主要的内存分配区域。新对象首先在这里分配内存，由于 Eden 区的空间通常较小，分配内存的速度很快。
- **垃圾回收**：新生代的 Minor GC 频率较高，但每次回收的开销相对较小。而老年代的 Full GC 频率较低，但回收的开销较大。通过这种方式，JVM 可以在大部分时间里只进行 Minor GC，从而减少对应用程序性能的影响。

**四、减少整体垃圾回收的暂停时间**

- **分代回收**：由于新生代中的对象大部分是垃圾，Minor GC 可以快速清理这些对象。老年代中的对象较少，Full GC 的频率较低。通过这种方式，整体的垃圾回收暂停时间可以得到很好的控制。
- **响应性提升**：这种方法可以确保应用程序在大部分时间里保持较高的响应性，因为垃圾回收的暂停时间相对较短。

## Eden区与Survivor区（S0和S1）的比例为什么为8:1:1

1. 减少内存碎片

- **内存碎片问题**：如果只有一个Survivor区，当对象在Eden区和Survivor区之间复制时，可能会导致内存碎片。通过使用两个Survivor区，可以确保每次复制时都有一个Survivor区是空的，从而避免内存碎片问题。
- **内存分配连续性**：两个Survivor区的存在确保了内存分配的连续性，避免了因内存碎片导致的分配失败。

2. 提高内存利用率

- **Eden区占比大**：Eden区占用80%的内存空间，Survivor区占用20%的内存空间。这种比例设计是为了充分利用内存资源，因为大多数对象在新生代中存活时间较短，很快就会被回收。
- **Survivor区的平衡**：两个Survivor区各占10%的内存空间，确保在复制过程中有足够的空间存储存活对象，同时避免浪费内存。

3. 适应对象生命周期

- **年轻对象的快速回收**：大多数对象在Eden区创建后很快就会被回收，只有少数对象会复制到Survivor区。这种设计适应了年轻对象的生命周期，提高了垃圾回收的效率。
- **对象晋升机制**：经过几次Minor GC后，仍然存活的对象会被晋升到老年代。这种机制确保了老年代中存储的是生命周期较长的对象。

4. 优化垃圾回收性能

- **复制算法的高效性**：使用复制算法（Copying Algorithm）进行垃圾回收时，将Eden区和一个Survivor区的对象复制到另一个Survivor区。这种算法在新生代中非常高效，因为新生代中的对象大部分是垃圾，复制的对象较少。
- **减少Full GC的频率**：通过将对象及时晋升到老年代，减少了老年代的Full GC频率，从而提高了整体性能。

## 对象的创建过程

1. **类加载检查**：

    在对象创建之前，必须确保类已经加载到 JVM 中。

    - **加载**：类加载器（ClassLoader）负责将类的字节码文件从磁盘加载到内存中。这个过程包括从本地文件系统、网络或其他来源加载类。
    - **链接**：
      - **验证**：确保加载的类字节码符合 Java 虚拟机规范，不会破坏 JVM 的安全性和稳定性。
      - **准备**：为类的静态变量分配内存，并设置默认的初始值。
      - **解析**：将类中的符号引用（如类名、方法名、字段名等）替换为直接引用（如内存地址）。
    - **初始化**：执行类的静态初始化块和静态变量的赋值操作。

2. **分配内存**：

    当类加载完成并且准备好之后，JVM 会为对象分配内存。

    - **确定对象大小**：JVM 根据类的结构（包括字段大小和类型）计算对象所需的内存大小。
    - **分配内存**：
      - **内存布局**：分配的内存空间包括对象头（用于存储对象的元数据，如 hashCode、GC 信息等）和实例数据。
      - **内存分配方式**：
        - **指针碰撞**：如果 JVM 的堆内存是空闲并且是连续的，分配内存就像移动一个指针一样简单。
        - **空闲列表**：如果堆内存中有碎片，JVM 会维护一个列表来跟踪空闲的内存块，并从中分配内存。

3. **初始化为零值**：

    在分配内存后，JVM 会初始化对象的内存空间，将所有字段设置为零值（例如，数字类型为 0，引用类型为 null）。

4. **设置对象头：**

    - 包括对象的哈希码、GC分代年龄、锁信息等。

5. **执行构造函数**：

    在内存分配和初始化之后，JVM 会调用类的构造函数来初始化对象。

    - **执行初始化代码**：构造函数中的代码会执行，为对象的字段赋值，并执行其他必要的初始化操作。
    - **递归初始化父类**：如果类有父类，JVM 会先调用父类的构造函数，然后再调用当前类的构造函数。这是因为子类继承了父类的字段和方法，父类的初始化必须在子类初始化之前完成。

6. **返回对象引用**

    在构造函数执行完毕后，JVM 返回一个指向新创建对象的引用。这个引用可以用于访问对象的字段和方法。

## 方法区、元空间和永久代有什么关系

1. 方法区（Method Area）

- **定义**：方法区是 JVM 规范中定义的一个内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- **特点**：
  - 它是各个线程共享的内存区域，包括存储类的结构信息（如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容等）。
  - 运行时常量池是方法区的一部分，是每个类或接口的常量池的运行时表示形式，用于存储编译期生成的各种字面量和符号引用。

2. 永久代（PermGen）

- **定义**：永久代是 HotSpot 虚拟机（ Oracle JDK 7 及之前版本 ）对方法区的一种实现方式。
- **特点**：
  - 它是方法区的物理实现，主要用于存储类的结构信息、常量池、静态变量等。
  - 永久代的大小是固定的，可以通过 JVM 参数（如 `-XX:PermSize` 和 `-XX:MaxPermSize`）进行设置。
  - 永久代的问题在于，当应用程序加载大量类时，容易导致内存溢出（`OutOfMemoryError: PermGen space`），因为它的大小是固定的，无法根据实际需求动态扩展。

3. 元空间（Metaspace）

- **定义**：元空间是 JDK 8 及之后版本中对方法区的一种新的实现方式，它取代了永久代。
- **特点**：
  - 元空间使用的是本地内存（即操作系统的内存），而不是 JVM 内存的一部分，因此其大小可以动态扩展，理论上只受操作系统的限制。
  - 元空间的大小可以通过 JVM 参数（如 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize`）进行设置，但它的默认行为是自动扩展。

关系和区别

- **方法区**：JVM 规范中定义的一个内存区域，用于存储类的元数据等信息。
- **永久代**：是 HotSpot 虚拟机在 JDK 8 之前对方法区的一种具体实现，但由于其大小固定且容易导致内存问题，现在已经不再使用。
- **元空间**：是 JDK 8 及之后版本中 HotSpot 虚拟机对方法区的一种新的实现，它使用本地内存，避免了永久代存在的问题，并且能够更高效地管理类的元数据。

主要区别在于：

- **位置**：永久代在 JVM 堆内存中，而元空间在本地内存中。
- **大小限制**：永久代有固定的大小限制，元空间的大小受本地内存限制。
- **内存溢出**：永久代满了会抛出 `OutOfMemoryError: PermGen space`，而元空间满了会抛出 `OutOfMemoryError: Metaspace`。

方法区是 JVM 规范中定义的一个内存区域，用于存储类的元数据等信息。永久代和元空间都是方法区的具体实现，但它们存在于不同的 Java 版本中。永久代在 Java 8 之前使用，而元空间从 Java 8 开始使用，提供了更大的灵活性和更高效的内存管理。

## 垃圾回收算法

垃圾回收（Garbage Collection, GC）是 Java 虚拟机（JVM）中的一项重要功能，用于自动管理内存。JVM 通过垃圾回收算法来回收不再使用的对象，从而避免内存泄漏和内存溢出问题。以下是几种常见的垃圾回收算法：

1. **标记-清除算法（Mark-Sweep）**

工作原理

1. **标记阶段**：从根对象（如栈、静态变量等）出发，标记所有可达对象。
2. **清除阶段**：遍历堆内存，回收未被标记的对象。

优点

- 简单易实现。

缺点

- **内存碎片**：清除后会产生不连续的内存碎片，影响内存分配效率。
- **停顿时间**：标记和清除过程需要暂停应用程序（Stop-The-World）。



2. **标记-整理算法（Mark-Compact）**

工作原理

1. **标记阶段**：与标记-清除算法相同，标记所有可达对象。
2. **整理阶段**：将所有存活对象向内存的一端移动，然后清理边界外的内存。

优点

- **无内存碎片**：整理后的内存是连续的，适合大对象分配。

缺点

- **性能开销**：整理阶段需要移动对象，增加了时间开销。



3. **复制算法（Copying）**

工作原理

1. 将内存分为两块：**From 空间**和**To 空间**。
2. **复制阶段**：将 From 空间中的存活对象复制到 To 空间。
3. **清理阶段**：清空 From 空间，然后交换 From 和 To 空间的角色。

优点

- **无内存碎片**：复制后的内存是连续的。
- **高效**：只需要遍历存活对象，适合存活率低的内存区域。

缺点

- **内存浪费**：只能使用一半的内存空间。

使用场景

- 新生代垃圾回收（如 Serial、ParNew、G1 的新生代）。



4. **分代收集算法（Generational Collection）**

核心思想

- 根据对象的生命周期将堆内存分为不同的代：
  - **新生代（Young Generation）**：存放新创建的对象。
  - **老年代（Old Generation）**：存放长时间存活的对象。
- 对不同代使用不同的垃圾回收算法。

新生代回收（Minor GC）

- 使用**复制算法**，因为新生代的对象存活率低。
- 分为 Eden 区、Survivor From 区和 Survivor To 区。

老年代回收（Major GC/Full GC）

- 使用**标记-清除**或**标记-整理算法**，因为老年代的对象存活率高。

优点

- **高效**：针对不同代的特点使用合适的算法。
- **减少停顿时间**：大多数情况下只回收新生代。

缺点

- **复杂度高**：需要管理多个代的内存。



5. **增量收集算法（Incremental Collecting）**

核心思想

- 将垃圾回收过程分为多个小步骤，与应用程序交替执行。
- 减少单次垃圾回收的停顿时间。

优点

- **减少停顿时间**：适合对响应时间要求高的应用。

缺点

- **吞吐量降低**：垃圾回收的总时间可能增加。



6. **分区收集算法（Region-Based Collecting）**

核心思想

- 将堆内存划分为多个独立的分区（Region），每个分区可以独立进行垃圾回收。
- 优先回收垃圾较多的分区。

优点

- **局部回收**：减少每次回收的范围，降低停顿时间。
- **灵活性高**：适合大内存应用。

使用场景

- G1 垃圾回收器。

## 垃圾收集器

一、单线程收集器

- **Serial 收集器**：

  - **特点**：

    - **单线程**：使用单个线程进行垃圾回收。
    - **Stop-The-World**：在垃圾回收时，会暂停所有应用线程。

  - **适用场景**：

    - 单核 CPU 或小内存应用。
    - 客户端应用（如桌面程序），默认采用 Serial 收集器。

  - **回收方式**：会暂停所有用户线程（Stop-the-World）。

  - **启用参数**

    ```
    -XX:+UseSerialGC
    ```

二、多线程收集器

- **ParNew 收集器**：

  - **特点**：

    - **多线程**：使用多个线程进行垃圾回收。
    - **高吞吐量**：适合需要高吞吐量的应用。

  - **适用场景**：

    - 多核 CPU、大内存应用。
    - 后台计算任务（如批处理）。

  - **回收方式**：也是暂停所有用户线程（Stop-the-World）。

  - **启用参数**

    ```
    -XX:+UseParallelGC
    ```

三、并发收集器

- **CMS 收集器（Concurrent Mark Sweep）**：

  - **特点**：

    - **并发收集**：大部分垃圾回收工作与应用线程并发执行。
    - **低停顿时间**：适合对延迟敏感的应用。

  - **缺点**

    - **内存碎片**：使用标记-清除算法，可能产生内存碎片。
    - **CPU 敏感**：并发阶段会占用 CPU 资源。

  - **适用场景**：对延迟敏感的应用（如 Web 服务）。

  - **回收方式**：

    - 大部分工作与用户线程同时执行，可以大大减少系统停顿时间。
    - 但可能存在浮动垃圾，导致内存不足。

  - **启用参数**

    ```
    -XX:+UseConcMarkSweepGC
    ```

- **G1 收集器（Garbage First）**：

  - **特点**：

    - **分区收集**：将堆内存划分为多个 Region，优先回收垃圾最多的 Region。
    - **可控停顿时间**：通过设置最大停顿时间，平衡吞吐量和延迟。

  - **优点**

    - **高吞吐量**：适合大内存应用。
    - **低延迟**：通过分区回收减少停顿时间。

  - **适用场景**：

    - 大内存、多核 CPU 的应用。
    - 对延迟和吞吐量都有要求的应用。

  - **回收方式**：

    - 将堆内存划分为多个 Region，可以并行和并发地回收这些 Region。
    - 在整个收集阶段，用户线程和垃圾回收线程可以并行工作，减少了系统停顿时间。

  - #### 启用参数

    ```
    -XX:+UseG1GC
    ```

- **ZGC（Z Garbage Collector）**

  - **特点**

    - **极低停顿时间**：目标是将停顿时间控制在 10ms 以内。

    - **并发回收**：大部分垃圾回收工作与应用线程并发执行。

    - **大内存支持**：可处理 TB 级别的堆内存。

  - **优点**

    - **超低延迟**：适合对延迟极其敏感的应用。

    - **高吞吐量**：适合大内存应用。

  - **适用场景**
    - 超大内存、超低延迟的应用（如实时系统）。

  - **启用参数**

    ```
    -XX:+UseZGC
    ```

- **Shenandoah GC**

  - **特点**

    - **低停顿时间**：与 ZGC 类似，目标是将停顿时间控制在 10ms 以内。

    - **并发整理**：通过并发整理减少停顿时间。

  - **优点**

    - **低延迟**：适合对延迟敏感的应用。

    - **兼容性好**：支持较老的硬件和操作系统。

  - **适用场景**
    - 对延迟敏感的应用（如实时系统）。

- **Epsilon GC**

  - **特点**

    - **无操作收集器**：不进行任何垃圾回收，仅分配内存。

    - **适用于测试**：用于性能测试和内存压力测试。

  - **适用场景**

    - 测试环境，验证应用的内存使用情况。

  - **启用参数**

    ```
    -XX:+UseEpsilonGC
    ```

垃圾收集器是 JVM 内存管理的核心组件，不同的收集器适用于不同的场景：

- **Serial GC**：单线程，适合小内存应用。
- **Parallel GC**：多线程，适合高吞吐量应用。
- **CMS GC**：低延迟，适合对延迟敏感的应用。
- **G1 GC**：分区收集，适合大内存应用。
- **ZGC/Shenandoah**：超低延迟，适合超大内存和实时系统。

## 垃圾收集器的选择

选择合适的垃圾收集器需要考虑以下因素：

1. **应用场景**：
   - 低延迟：选择 ZGC 或 Shenandoah。
   - 高吞吐量：选择 Parallel GC 或 G1。
2. **堆内存大小**：
   - 小内存：Serial GC。
   - 大内存：G1、ZGC 或 Shenandoah。
3. **硬件资源**：
   - 多核 CPU：G1、Parallel GC。
   - 单核 CPU：Serial GC。

在 JVM 中，新生代和老年代可以使用不同的垃圾收集器组合。常见的组合包括：

- **Serial + Serial Old**：单线程收集器组合。
- **Parallel Scavenge + Parallel Old**：吞吐量优先的组合。
- **ParNew + CMS**：低延迟的组合。

## **垃圾收集器的参数调优**

以下是一些常用的 JVM 常见配置参数：

1. 堆大小相关

- **`-Xms<size>`**：设置 JVM 的初始堆内存大小。例如：`-Xms512m` 表示初始堆内存为 512MB。
- **`-Xmx<size>`**：设置 JVM 的最大堆内存大小。例如：`-Xmx1024m` 表示最大堆内存为 1024MB。
- **`-Xss<size>`**：设置每个线程的堆栈大小。例如：`-Xss256k` 表示每个线程的堆栈大小为 256KB。

2. 垃圾回收器相关

- **`-XX:+UseSerialGC`**：使用 Serial 垃圾收集器。
- **`-XX:+UseParallelGC`**：使用 Parallel 垃圾收集器（吞吐量优先）。
- **`-XX:+UseParNewGC`**：使用 ParNew 垃圾收集器（低延迟优先）。
- **`-XX:+UseConcMarkSweepGC`**：使用 CMS 垃圾收集器（低延迟优先）。
- **`-XX:+UseG1GC`**：使用 G1 垃圾收集器（适用于大内存场景）。

3. 垃圾回收日志相关

- **`-XX:+PrintGC`**：打印垃圾回收日志。
- **`-XX:+PrintGCDetails`**：打印详细的垃圾回收日志。
- **`-XX:+PrintGCTimeStamps`**：在垃圾回收日志中打印时间戳。
- **`-Xloggc:<file>`**：将垃圾回收日志输出到指定文件。

4. 永久代相关（Java 8 及以下）

- **`-XX:PermSize=<size>`**：设置永久代的初始大小。例如：`-XX:PermSize=64m`。
- **`-XX:MaxPermSize=<size>`**：设置永久代的最大大小。例如：`-XX:MaxPermSize=256m`。

5. 元空间相关（Java 8 及以上）

- **`-XX:MetaspaceSize=<size>`**：设置初始的元空间大小。例如：`-XX:MetaspaceSize=128m`。
- **`-XX:MaxMetaspaceSize=<size>`**：设置最大元空间大小。例如：`-XX:MaxMetaspaceSize=512m`。

6. 其他常用参数

- **`-XX:+AggressiveOpts`**：启用更多性能优化。
- **`-XX:+TieredCompilation`**：启用分层编译。
- **`-XX:+UseCompressedOops`**：启用指针压缩（节省内存）。
- **`-XX:MaxDirectMemorySize=<size>`**：设置直接内存的最大大小。例如：`-XX:MaxDirectMemorySize=256m`。

示例

```
java -Xms512m -Xmx1024m -Xss256k -XX:+UseG1GC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log MyApp
```

这个命令设置了 JVM 的初始堆内存为 512MB，最大堆内存为 1024MB，每个线程的堆栈大小为 256KB，使用 G1 垃圾收集器，并打印详细的垃圾回收日志到 `gc.log` 文件中。