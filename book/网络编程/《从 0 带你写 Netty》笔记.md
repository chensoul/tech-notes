Netty 是一个建立在 NIO 模式之上的框架，它对 NIO 模式做了一层封装，并在其之上扩展了许多功能。因此，Netty 的高性能和 NIO 模式处理数据的效率息息相关。

## BIO

BIO（Blocking I/O）是传统的 Java I/O 编程模型，采用同步阻塞的方式进行 I/O 操作。服务器端为每个客户端连接创建一个独立的线程来处理请求。这种方式适用于连接数较少且固定的场景，但在高并发情况下性能较差，因为每个连接都需要一个独立的线程，线程的创建和切换会消耗大量资源。

BIO 工作机制

- **服务器端**：
  1. 通过 `ServerSocket` 注册端口。
  2. 服务器端通过调用 serverSocket 的 `accept` 方法监听客户端的 `Socket` 请求。
  3. 从 `Socket` 中获取字节输入或输出流进行数据读写操作。
- **客户端**：
  1. 通过 `Socket` 对象请求与服务器端建立连接。
  2. 从 `Socket` 中获取字节输入或输出流进行数据读写操作。

## NIO 是什么？

而 NIO 就是在计算机进行网络 IO 时，接收和发送数据的一种方式。它是一种同步非阻塞的 I/O 模型 ，是在 JDK 1.4 版本被提出来的。

### NIO 为什么诞生？

最开始，在进行网络 IO 的过程中，是以 BIO（阻塞 IO 模型），也就是以流的形式，一次一个字节地接收或发送数据。比如服务端接收客户端的连接时，**服务端每接收到一个连接就要创建一个线程**，并且该线程只对该连接负责。如果该线程管理的客户端连接迟迟没有再发送数据过来，那么该线程就会一直阻塞，直到有数据到来，才会继续开始工作。

比如，当服务端要接收来自 4 个客户端的连接时，就要创建4个线程，如果之后这些连接再没发送数据过来，这 4 个线程就会阻塞。连接客户端较少的情况下并不会有处理压力，只是有些浪费线程资源，但如果来自客户端的连接不断增加，达到成千上万个，再按照 BIO 模式接收网络数据就太荒谬了。

因为线程并不是凭空存在的，每一个线程都会占用一定的内存，而且线程的切换会耗费大量时间，甚至切换线程的时间会超过我们程序执行的时间。另外在 Java 中，线程的创建和销毁实际上都是操作系统帮我们完成的，频繁创建和销毁线程也很耗时。最后，也是最不能容忍的，如果线程管理的客户端连接没有数据到来，那么大面积的线程都将阻塞，资源会被白白浪费了。

由此可见，在处理器核数一定的情况下，**BIO** **实际上只适用于客户端连接比较少的情况**，并不适用于高并发场景。那么，在处理器核数一定的情况下，如何创建较少的线程来管理众多客户端连接呢？这就轮到 NIO的多路复用机制登场了。

## NIO 中的多路复用机制

和 BIO 有所区别，NIO 并不是以流的方式来接收和发送数据的，它用的是 Buffer 缓冲区。也就是说，在 NIO 中，要操作的数据全部先放入缓冲区，再由缓冲区向外发送，这显然比一次一个字节处理数据的流要高效很多。

那么，NIO 的 IO 多路复用机制又是什么，如何利用它实现以较少的线程管理众多客户端连接呢？

所谓多路复用，说到底就一句话，**就是用一个线程管理多个连接，管理多个连接的数据收发** **。当然，** **多路复用** **也可以理解为** **是用** **selector** **管理多个** **channel** **，处理每个 channel 到来的** **IO** **事件。** 这两种解释其实只是外在和内在的区别，因为从表面上看，确实是一个线程管理了多个客户端连接，但深入到内部，实际上是 selector 管理了多个客户端 channel，每当有 IO 事件到来，就交给该线程去处理。多路复用最终的效果就是，服务器再也不必每接收一个客户端连接就创建一个线程了。