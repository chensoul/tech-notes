# 内存管理

## 内存区域

### 运行时数据区域

#### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

#### Java虚拟机栈

与程序计数器一样，Java虚拟机栈（Java V irtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 **returnAddress 类型**（指向了一条字节码指令的地址）。

在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

#### 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

#### 堆

堆是 JVM 中最⼤的⼀块内存区域，被所有线程共享，在 JVM 启动时创建，主要⽤来存储 new 出来的对象和数组。

在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”。

从内存回收的⻆度来看，由于垃圾收集器⼤部分都是基于分代收集理论设计的，所以堆⼜被细分为 新⽣代 、 ⽼年代 、 Eden空间 、 From Survivor空间 、 To Survivor空间 等。

堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

随着 JIT 编译器的发展和逃逸技术的逐渐成熟，“所有的对象都会分配到堆上”就不再那么绝对了。
从 JDK 7 开始，JVM 默认开启了逃逸分析，意味着如果某些⽅法中的对象引⽤没有被返回或者没有在⽅法体外使⽤，也就是未逃逸出去，那么对象可以直接在栈上分配内存。

> 面试题：**堆和栈的区别是什么？**
>
> 堆属于线程共享的内存区域，⼏乎所有 new 出来的对象都会堆上分配，⽣命周期不由单个⽅法调⽤所决定，可以在⽅法调⽤结束后继续存在，直到不再被任何变量引⽤，最后被垃圾收集器回收。
>
> 栈属于线程私有的内存区域，主要存储局部变量、⽅法参数、对象引⽤等，通常随着⽅法调⽤的结束⽽⾃动释放，不需要垃圾收集器处理。

#### 方法区

方法区与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

在 HotSpot 虚拟机中，⽅法区的实现称为永久代 PermGen，但在 Java 8 及之后的版本中，已经被元空间Metaspace 所替代。

>  面试题：JDK 1.6、1.7、1.8 内存区域的变化？
>
> - JDK 1.6 使⽤永久代来实现⽅法区：
> - JDK 1.7 时仍然是永久代，但发⽣了⼀些细微变化，⽐如将字符串常量池、静态变量存放到了堆上。
> - JDK 1.8 时，直接在内存中划出了⼀块区域，叫元空间，来取代之前放在 JVM 内存中的永久代，并将运⾏时常量池、类常量池都移动到了元空间。

为什么使⽤元空间替代永久代？

- 永久代会导致 Java 应⽤程序更容易出现内存溢出的问题，因为它要受到 JVM 内存⼤⼩的限制。
- 元空间的⼤⼩不再受到 JVM 内存的限制。

根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

> 面试题：**变量存在堆栈的什么位置？**
>
> 对于局部变量，它存储在当前⽅法栈帧中的局部变量表中。当⽅法执⾏完毕，栈帧被回收，局部变量也会被释放。
>
> 对于静态变量来说，它存储在 Java 虚拟机规范中的⽅法区中，在 Java 7 中是永久代，在 Java8 及以后是元空间。

#### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

Java语言并不要求常量一定只有编译期才能产生，运行期间也可以将新的常量放入池中，例如 String类的 intern() 方法。

#### 直接内存

在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

直接内存超过物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。

### 对象的创建

当Java虚拟机遇到一条字节码 **new 指令**时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的**类加载过程**。

在类加载检查通过后，接下来虚拟机将为新生对象**分配内存**。对象所需内存的大小在类加载完成后便可完全确定。

> 1. 堆内存是如何分配的？
>
> 在堆中为对象分配内存时，主要使⽤两种策略：指针碰撞和空闲列表。
>
> - **指针碰撞**：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。
> - **空闲列表**：如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
>
> 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，**理论上**就只能采用较为复杂的空闲列表来分配内存。
>
> 强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。
>
> 
>
> 2. 怎么解决堆内存分配的竞争问题？
>
> - 一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。
>
> - 另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都**初始化为零值**，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。

接下来，**设置对象头**，包括类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。

最后，JVM 会**执⾏构造⽅法** `<init>` 完成赋值操作，将成员变量赋值为预期的值，这样⼀个对象就创建完成了。

> 面试题：new 对象时，堆会发⽣抢占吗？
>
> 会。
>
> 为了解决堆内存分配的竞争问题，JVM 为每个线程保留了⼀⼩块内存空间，被称为 TLAB，也就是线程本地分配缓冲区，⽤于存放该线程分配的对象。
>
> 当线程需要分配对象时，直接从 TLAB 中分配。只有当 TLAB ⽤尽或对象太⼤需要直接在堆中分配时，才会使⽤全局分配指针。

### 对象的内存布局

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

对象头部分包括两类信息：

- Mark Word：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等.
  - 在 64 位 JVM 上，未开启压缩指针时，对象引⽤占⽤ 8 字节；开启压缩指针时，对象引⽤会被压缩到 4 字节。
  - 在 JDK 8 中，压缩指针默认是开启的。
- 类型指针：指向对象所属类的元数据，也就是 Class 对象，⽤来⽀持多态、⽅法调⽤等功能。
  - 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。
  - 如果对象是数组类型，还会有⼀个额外的数组⻓度字段，占 4 个字节。

实例数据是对象实际的字段值，也就是成员变量的值，包括父类的，按照字段在类中声明的顺序存储。JVM 会对这些数据进⾏对⻬/重排，以提⾼内存访问速度。

对齐填充仅仅起着占位符的作用。由于 JVM 的内存模型要求对象的起始地址是 8 字节对⻬（64 位 JVM 中），因此对象的总⼤⼩必须是 8 字节的倍数。如果对象头和实例数据的总⻓度不是 8 的倍数，JVM 会通过填充额外的字节来对⻬。

> 面试题：为什么⾮要进⾏ 8 字节对⻬呢？
> 因为 CPU 进⾏内存访问时，⼀次寻址的指针⼤⼩是 8 字节，正好是 L1 缓存⾏的⼤⼩。如果不进⾏内存对⻬，则可能出现跨缓存⾏访问，导致额外的缓存⾏加载，CPU 的访问效率就会降低。

> 面试题？new Object() 对象的内存⼤⼩是多少？
>
> ⼀般来说，⽬前的操作系统都是 64 位的，并且 JDK 8 中的压缩指针是默认开启的，因此在 64 位的 JVM 上， new Object() 的⼤⼩是 16 字节（12 字节的对象头 + 4 字节的对⻬填充）。
>
> ![	](assets/image-20250320143631391.png)
>
> 实例数据的⼤⼩取决于对象的成员变量和它们的类型。对于 new Object() 来说，由于默认没有成员变量，因此我们可以认为此时的实例数据⼤⼩是 0。
>
> 假如 MyObject 对象有三个成员变量，分别是 int、long 和 byte 类型，那么它们占⽤的内存⼤⼩分别是 4 字节、8 字节和 1 字节。
>
> 考虑到对⻬填充，MyObject 对象的总⼤⼩为 12（对象头） + 4（a） + 8（b） + 1（c） + 7（填充） = 32 字节。



> ⽤过 JOL 查看对象的内存布局吗？
>
> ```xml
> <dependency>
> 	<groupId>org.openjdk.jol</groupId>
> 	<artifactId>jol-core</artifactId>
> 	<version>0.9</version>
> </dependency>
> ```
>
> ```java
> public class JOLSample {
>   public static void main(String[] args) {
>     // 打印JVM详细信息（可选）
>     System.out.println(VM.current().details());
>     // 创建Object实例
>     Object obj = new Object();
>     // 打印Object实例的内存布局
>     String layout = ClassLayout.parseInstance(obj).toPrintable();
>     System.out.println(layout);
>   }
> }
> ```

> 面试题：对象的引⽤⼤⼩了解吗？
>
> 在 64 位 JVM 上，未开启压缩指针时，对象引⽤占⽤ 8 字节；开启压缩指针时，对象引⽤会被压缩到 4 字节。

### 对象的访问定位

Java程序会通过栈上的 reference 数据来操作堆上的具体对象。

主流的⽅式有两种：

- 句柄：Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。
  - 好处：在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
- 直接指针：reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。
  - 好处：速度更快，它节省了一次指针定位的时间开销。
  - 缺点：如果对象在内存中移动，引⽤需要更新为新的地址。

### 逃逸分析

逃逸分析是⼀种 JVM 优化技术，⽤来分析对象的作⽤域和⽣命周期，判断对象是否逃逸出⽅法或线程。

可以通过分析对象的引⽤流向，判断对象是否被⽅法返回、赋值到全局变量、传递到其他线程等，来确定对象是否逃逸。如果对象没有逃逸，就可以进⾏栈上分配、同步消除、标量替换等优化，以提⾼程序的性能。

可以通过` java -XX:+PrintFlagsFinal -version | grep DoEscapeAnalysis` 来确认 JVM 是否开启了逃逸分析。

根据对象逃逸的范围，可以分为⽅法逃逸和线程逃逸。

当对象被⽅法外部的代码引⽤，⽣命周期超出了⽅法的范围，那么对象就必须分配在堆中，由垃圾收集器管理。

```java
public Person createPerson() {
	return new Person(); // 对象逃逸出⽅法
}
```

再⽐如说，对象被另外⼀个线程引⽤，⽣命周期超出了当前线程，那么对象就必须分配在堆中，并且线程之间需要同步。

 ```java
 public void threadEscapeExample() {
   Person p = new Person(); // 对象逃逸到另⼀个线程
   new Thread(() -> {
   		System.out.println(p);
    }).start();
 }
 ```

逃逸分析会带来什么好处：

- 如果确定⼀个对象不会逃逸，那么就可以考虑栈上分配，对象占⽤的内存随着栈帧出栈后销毁，这样⼀来，垃圾收集的压⼒就降低很多。

- 线程同步需要加锁，加锁就要占⽤系统资源，如果逃逸分析能够确定⼀个对象不会逃逸出线程，那么这个对象就不⽤加锁，从⽽减少线程同步的开销。

- 如果对象的字段在⽅法中独⽴使⽤，JVM 可以将对象分解为标量变量，避免对象分配。

  ```java
  public void scalarReplacementExample() {
  	Point p = new Point(1, 2);
    System.out.println(p.getX() + p.getY());
  }
  ```

  如果 Point 对象未逃逸，JVM 可以优化为：
  ```java
  int x = 1;
  int y = 2;
  System.out.println(x + y);
  ```

### 内存溢出

StackOverflowError 原因：

- 递归调⽤

- 如果⽅法中定义了特别⼤的局部变量，栈帧会变得很⼤，导致栈空间更容易耗尽

OutOfMemoryError 原因：

- 

1. 堆内存溢出异常测试

```java
/**
* VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
* @author zzm
*/
public class HeapOOM {
  static class OOMObject {
  }
  public static void main(String[] args) {
    List<OOMObject> list = new ArrayList<OOMObject>();
    while (true) {
    	list.add(new OOMObject());
    }
  }
}
```

使用 Eclipse Memory Analyzer 工具，要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们。

如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

2. 虚拟机栈和本地方法栈溢出

```java
/**
* VM Args：-Xss128k   StackOverflowError
* @author zzm
*/
public class JavaVMStackSOF {
  private int stackLength = 1;
  public void stackLeak() {
    stackLength++;
    stackLeak();
  }
  public static void main(String[] args) throws Throwable {
    JavaVMStackSOF oom = new JavaVMStackSOF();
    try {
    	oom.stackLeak();
    } catch (Throwable e) {
    	System.out.println("stack length:" + oom.stackLength);
    	throw e;
    }
  }
}
```

3. 方法区和运行时常量池溢出

JDK6

```java
/**
*  VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M
* @author zzm
*/
public class RuntimeConstantPoolOOM {
  public static void main(String[] args) {
    // 使用Set保持着常量池引用，避免Full GC回收常量池行为
    Set<String> set = new HashSet<String>();
    // 在short范围内足以让6MB的PermSize产生OOM了
    short i = 0;
    while (true) {
    	set.add(String.valueOf(i++).intern());
    }
  }
}
```

JDK7：

```java
/**
* VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M
* @author zzm
*/
public class JavaMethodAreaOOM {
  public static void main(String[] args) {
    while (true) {
      Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(OOMObject.class);
      enhancer.setUseCache(false);
      enhancer.setCallback(new MethodInterceptor() {
        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Thro
          return proxy.invokeSuper(obj, args);
        }
      });
      enhancer.create();
    }
    
    static class OOMObject {
    }
  }
}
```

4. 本机直接内存溢出

```java
/**
* VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M
* @author zzm
*/
public class DirectMemoryOOM {
	private static final int _1MB = 1024 * 1024;

	public static void main(String[] args) throws Exception {
    Field unsafeField = Unsafe.class.getDeclaredFields()[0];
    unsafeField.setAccessible(true);
    Unsafe unsafe = (Unsafe) unsafeField.get(null);
    while (true) {
      unsafe.allocateMemory(_1MB);
    }
  }
}
```

>面试题：内存溢出和内存泄漏的区别？
>
>内存溢出，俗称 OOM，是指当程序请求分配内存时，由于没有⾜够的内存空间，从⽽抛出 OutOfMemoryError。
>
>内存泄漏通常是因为⻓期存活的对象持有短期存活对象的引⽤，⼜没有及时释放，从⽽导致短期存活对象⽆法被回收⽽导致的。

## 垃圾收集器与内存分配策略

### 对象存活性分析

#### 引用计数算法

每个对象有⼀个引⽤计数器，记录引⽤它的次数。当计数器为零时，对象可以被回收。

引⽤计数法⽆法解决循环引⽤的问题。例如，两个对象互相引⽤，但不再被其他对象引⽤，它们的引⽤计数都不为零，因此不会被回收。

#### 可达性分析算法

通过⼀组名为 “GC Roots” 的根对象，进⾏递归扫描，⽆法从根对象到达的对象就是“垃圾”，可以被回收。

这也是 G1、CMS 等主流垃圾收集器使⽤的主要算法。



可作为GC Roots的对象包括以下几种：

- 虚拟机栈中的引⽤（⽅法的参数、局部变量、临时变量等）

  ```java
  public class StackReference {
     public void greet() {
    		Object localVar = new Object(); // 这⾥的 localVar 是⼀个局部变量，存在于虚拟机栈中
    		System.out.println(localVar.toString());
     }
    
     public static void main(String[] args) {
      	new StackReference().greet();
     }
  }
  ```

- 本地⽅法栈中 JNI 的引⽤

- 类静态变量

  ```java
  public class StaticFieldReference {
    	private static Object staticVar = new Object(); // 类静态变量
    	
      public static void main(String[] args) {
    		System.out.println(staticVar.toString());
     }
  }
  ```

- 运⾏时常量池中的常量（String 或 Class 类型）

  ```java
  class ConstantPoolReference {
    public static final String CONSTANT_STRING = "Hello, World"; // 常量，存在于运⾏时常量池中
    public static final Class<?> CONSTANT_CLASS = Object.class; // 类类型常量
    
    public static void main(String[] args) {
    	System.out.println(CONSTANT_STRING);
      System.out.println(CONSTANT_CLASS.getName());
    }
  }
  ```

- 所有被同步锁（synchronized关键字）持有的对象。

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。



做可达性分析的时候，JVM 会暂停所有正在执⾏的应⽤线程。
这是因为可达性分析过程必须确保在执⾏分析时，内存中的对象关系不会被应⽤线程修改。如果不暂停应⽤线程，可能会出现对象引⽤的改变，导致垃圾回收过程中判断对象是否可达的结果不⼀致，从⽽引发严重的内存错误或数据丢失。

#### 对象引用

强引⽤、软引⽤、弱引⽤和虚引⽤。

强引⽤是 Java 中最常⻅的引⽤类型。使⽤ new 关键字赋值的引⽤就是强引⽤，只要强引⽤关联着对象，垃圾收集器就不会回收这部分对象，即使内存不⾜。

软引⽤于描述⼀些⾮必须对象，通过 SoftReference 类实现。软引⽤的对象在内存不⾜时会被回收。

弱引⽤⽤于描述⼀些短⽣命周期的⾮必须对象，如 ThreadLocal 中的 Entry，就是通过 WeakReference 类实现的。弱引⽤的对象会在下⼀次垃圾回收时会被回收，不论内存是否充⾜。

虚引⽤主要⽤来跟踪对象被垃圾回收的过程，通过 PhantomReference 类实现。虚引⽤的对象在任何时候都可能被回收。

#### finalize()方法

如果对象在进⾏可达性分析后发现没有与 GC Roots 相连接的引⽤链，那它将会被第⼀次标记，随后进⾏⼀次筛选。筛选的条件是对象是否有必要执⾏ finalize() ⽅法。

如果对象在 finalize() 中成功拯救⾃⼰——只要重新与引⽤链上的任何⼀个对象建⽴关联即可。
譬如把⾃⼰ （this 关键字）赋值给某个类变量或者对象的成员变量，那在第⼆次标记时它就”逃过⼀劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。

### 垃圾收集算法

垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。

**标记-清除算法**：分为两个阶段。优点是实现简单，缺点是执行效率不稳定；回收过程中会产⽣内存碎⽚。

- 标记：标记所有需要回收的对象
- 清除：回收所有被标记的对象

**标记-复制算法**：可以解决标记-清除算法的内存碎⽚问题，因为它将内存空间划分为两块，每次只使⽤其中⼀块。当这⼀块的内存⽤完了，就将还存活着的对象复制到另外⼀块上⾯，然后清理掉这⼀块。优点是运行高效；缺点是浪费了⼀半的内存空间。

标记-复制算法的标记阶段和复制阶段都会触发STW。

- 标记阶段停顿是为了保证对象的引⽤关系不被修改。
- 复制阶段停顿是防⽌对象在复制过程中被修改。

**标记-整理算法**：标记-清除复制算法的升级版，它不再划分内存空间，⽽是将存活的对象向内存的⼀端移动，然后清理边界以外的内存。缺点是移动对象的成本⽐较⾼。

### 分代收集算法

分代收集 算法是⽬前主流的垃圾收集算法，它根据对象存活周期的不同将内存划分为⼏块，⼀般分为新⽣代和⽼年代。



新⽣代：

新⽣代的垃圾收集主要采⽤标记-复制算法，因为新⽣代的存活对象⽐较少，每次复制少量的存活对象效率⽐较⾼。

基于这种算法，虚拟机将内存分为⼀块较⼤的 Eden 空间和两块较⼩的 Survivor 空间，默认 Eden 和 Survivor 的⼤⼩⽐例是 8∶1。

新创建的对象会被分配到 Eden 空间。当 Eden 区填满时，会触发⼀次 Minor GC，清除不再使⽤的对象。存活下来的对象会从 Eden 区移动到 Survivor 区。
对象在新⽣代中经历多次 GC 后，如果仍然存活，会被移动到⽼年代。当⽼年代内存不⾜时，会触发 Major GC，对整个堆进⾏垃圾回收。



进入老年代的对象：

- ⻓期存活的对象：JVM 会为对象维护⼀个“年龄”计数器，记录对象在新⽣代中经历 Minor GC 的次数。每次 GC 未被回收的对象，其年龄会加 1。当超过⼀个特定阈值，默认值是 15，就会被认为⽼对象了。
- ⼤对象：指占⽤内存较⼤的对象，如⼤数组、⻓字符串等。其⼤⼩由 JVM 参数 -XX:PretenureSizeThreshold 控制，但在 JDK 8 中，默认值为 0，也就是说默认情况下，对象仅根据 GC 存活的次数来判断是否进⼊⽼年代。
  - G1 垃圾收集器中，⼤对象会直接分配到 HUMONGOUS 区域。当对象⼤⼩超过⼀个 Region 容量的 50% 时，会被认为是⼤对象。
  - Region 的⼤⼩可以通过 JVM 参数 -XX:G1HeapRegionSize 来设置，默认情况下从 1MB 到 32MB 不等，会根据堆内存⼤⼩动态调整。
- 动态年龄判定：如果 Survivor 区中所有对象的总⼤⼩超过了⼀定⽐例，通常是 Survivor 区的⼀半，那么年龄较⼩的对象也可能会被提前晋升到⽼年代。这是因为如果年龄较⼩的对象在 Survivor 区中占⽤了较⼤的空间，会导致 Survivor 区中的对象复制次数增多，影响垃圾回收的效率。



Minor GC 也称为 Young GC，是指发⽣在年轻代的垃圾收集。

Major GC 也称为 Old GC，主要指的是发⽣在⽼年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。

Mixed GC ⼀次 GC 中同时清理年轻代和部分⽼年代。目前只有G1收集器会有这种行为。

Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和⽅法区。它是最耗时的 GC，通常在 JVM 压⼒很⼤时发⽣。



> 面试题：什么时候会触发 Full GC？
>
> - 执⾏ Young GC 后⽼年代没有⾜够的内存空间存放转⼊的对象
> - System.gc() 、 jmap -dump 等命令会触发 full gc

### 垃圾收集器

- Serial收集器：它是⼀个单线程⼯作的收集器，使⽤⼀个处理器或⼀条收集线程去完成垃圾收集⼯作。并且进⾏垃圾收集时，必须暂停其他所有⼯作线程，直到垃圾收集结束。

- ParNew收集器：是Serial收集器的多线程并行版本。
- Parallel Scavenge收集器：⼀款新⽣代收集器，基于标记-复制算法实现，也能够并⾏收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU ⽤于运⾏⽤户代码的时间和总消耗时间的⽐值，⽐值越⼤，说明垃圾收集的占⽐越⼩。

- Serial Old收集器：是 Serial 收集器的⽼年代版本，它同样是⼀个单线程收集器，使⽤标记-整理算法。

- Parallel Old收集器：是 Parallel Scavenge 收集器的⽼年代版本，基于标记-整理算法实现，使⽤多条 GC 线程在 STW 期间同时进⾏垃圾回收。

- CMS收集器：CMS 在 JDK 1.5 时引⼊，JDK 9 时被标记弃⽤，JDK 14 时被移除。CMS 是⼀种低延迟的垃圾收集器，采⽤标记-清除算法，分为初始标记、并发标记、重新标记和并发清除四个阶段，优点是垃圾回收线程和应⽤线程同时运⾏，停顿时间短，适合延迟敏感的应⽤，但容易产⽣内存碎⽚，可能触发 Full GC。
  - 初始标记：标记所有从 GC Roots 直接可达的对象，这个阶段需要 STW，但速度很快。
  - 并发标记：从初始标记的对象出发，遍历所有对象，标记所有可达的对象。这个阶段是并发进⾏的。
  - 重新标记：完成剩余的标记⼯作，包括处理并发阶段遗留下来的少量变动，这个阶段通常需要短暂的 STW 停顿。
  - 并发清除：清除未被标记的对象，回收它们占⽤的内存空间。

- G1 收集器：G1 在 JDK 1.7 时引⼊，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。G1 把 Java 堆划分为多个⼤⼩相等的独⽴区域Region，每个区域都可以扮演新⽣代或⽼年代的⻆⾊。同时，G1 还有⼀个专⻔为⼤对象设计的 Region，叫 Humongous 区。这种区域化管理使得 G1 可以更灵活地进⾏垃圾收集，只回收部分区域⽽不是整个新⽣代或⽼年代。优点是停顿时间可控，适合⼤堆场景，但调优较复杂。G1 收集器的运⾏过程⼤致可划分为这⼏个步骤：
  - ①、并发标记，G1 通过并发标记的⽅式找出堆中的垃圾对象。并发标记阶段与应⽤线程同时执⾏，不会导致应⽤线程暂停。
  - ②、混合收集，在并发标记完成后，G1 会计算出哪些区域的回收价值最⾼（也就是包含最多垃圾的区域），然后优先回收这些区域。这种回收⽅式包括了部分新⽣代区域和⽼年代区域。
    选择回收成本低⽽收益⾼的区域进⾏回收，可以提⾼回收效率和减少停顿时间。
  - ③、可预测的停顿，G1 在垃圾回收期间仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，⽤户可以 JVM 启动时指定期望停顿时间，G1 会尽可能地在这个时间内完成垃圾回收。

- ZGC 收集器：ZGC 是 JDK 11 时引⼊的⼀款低延迟的垃圾收集器，最⼤特点是将垃圾收集的停顿时间控制在 10ms 以内，即使在TB 级别的堆内存下也能保持较低的停顿时间。它通过并发标记和重定位来避免⼤部分 Stop-The-World 停顿，主要依赖指针染⾊来管理对象状态。适⽤于需要超低延迟的场景，⽐如⾦融交易系统、电商平台。
  - 标记对象的可达性：通过在指针上增加标记位，不需要额外的标记位即可判断对象的存活状态。
  - 重定位状态：在对象被移动时，可以通过指针染⾊来更新对象的引⽤，⽽不需要等待全局同步。

>  面试题：有了 CMS，为什么还要引⼊ G1？
>
> | 特性           | CMS                               | G1                             |
> | -------------- | --------------------------------- | ------------------------------ |
> | 设计⽬标       | 低停顿时间                        | 可预测的停顿时间               |
> | 并发性         | 是                                | 是                             |
> | 内存碎⽚       | 是，容易产⽣碎⽚                  | 否，通过区域划分和压缩减少碎⽚ |
> | 收集代数       | 年轻代和⽼年代                    | 整个堆，但区分年轻代和⽼年代   |
> | 并发阶段       | 并发标记、并发清理                | 并发标记、并发清理、并发回收   |
> | 停顿时间预测   | 较难预测                          | 可配置停顿时间⽬标             |
> | 容易出现的问题 | 内存碎⽚、Concurrent Mode Failure | 较少出现⻓时间停顿             |
>
> CMS 适⽤于对延迟敏感的应⽤场景，主要⽬标是减少停顿时间，但容易产⽣内存碎⽚。G1 则提供了更好的停顿时间预测和内存压缩能⼒，适⽤于⼤内存和多核处理器环境。

## 性能调优

### JVM 的常⻅参数

配置堆内存⼤⼩的参数有哪些？

- -Xms ：初始堆⼤⼩
- -Xmx ：最⼤堆⼤⼩
- -XX:NewSize=n ：设置年轻代⼤⼩
- -XX:NewRatio=n ：设置年轻代和年⽼代的⽐值。如：n 为 3 表示年轻代和年⽼代⽐值为 1：3，年轻代占总
  和的 1/4
- -XX:SurvivorRatio=n ：年轻代中 Eden 区与两个 Survivor 区的⽐值。如 n=3 表示 Eden 占 3 Survivor 占 2，⼀个 Survivor 区占整个年轻代的 1/5

配置 GC 收集器的参数有哪些？

- -XX:+UseSerialGC ：设置串⾏收集器
- -XX:+UseParallelGC ：设置并⾏收集器
- -XX:+UseParalledlOldGC ：设置并⾏⽼年代收集器
- -XX:+UseConcMarkSweepGC ：设置并发收集器

配置并⾏收集的参数有哪些？

- -XX:MaxGCPauseMillis=n ：设置最⼤垃圾回收停顿时间
- -XX:GCTimeRatio=n ：设置垃圾回收时间占程序运⾏时间的⽐例
- -XX:+CMSIncrementalMode ：设置增量模式，适合单 CPU 环境
- -XX:ParallelGCThreads=n ：设置并⾏收集器的线程数

打印 GC 回收的过程⽇志信息的参数有哪些？

- -XX:+PrintGC ：输出 GC ⽇志
- -XX:+PrintGCDetails ：输出 GC 详细⽇志
- -XX:+PrintGCTimeStamps ：输出 GC 的时间戳（以基准时间的形式）
- -Xloggc:filename ：⽇志⽂件的输出路径

## 问题排查

### CPU 占⽤过⾼

⾸先，使⽤ top 命令查看 CPU 占⽤情况，找到占⽤ CPU 较⾼的进程 ID。

接着，使⽤ jstack 命令查看对应进程的线程堆栈信息。

```bash
jstack -l <pid> > thread-dump.txt
```

上⾯ 这个命令会将所有线程的堆栈信息输出到 thread-dump.txt ⽂件中。然后再使⽤ top 命令查看进程中线程的占⽤情况，找到占⽤ CPU 较⾼的线程 ID。

```bash
top -H -p <pid>
```

注意，top 命令显示的线程 ID 是⼗进制的，⽽ jstack 输出的是⼗六进制的，所以需要将线程 ID 转换为⼗六进制。

```bash
printf "%x\n" PID
```

接着在 jstack 的输出中搜索这个⼗六进制的线程 ID，找到对应的堆栈信息。

最后，根据堆栈信息定位到具体的业务⽅法，查看是否有死循环、频繁的垃圾回收、资源竞争导致的上下⽂频繁切换等问题。

### 内存飙⾼

内存飚⾼⼀般是因为创建了⼤量的 Java 对象导致的，如果持续飙⾼则说明垃圾回收跟不上对象创建的速度，或者内存泄漏导致对象⽆法回收。

先观察垃圾回收的情况，可以通过 `jstat -gc PID 1000` 查看 GC 次数和时间。或者使⽤ `jmap -histo PID | head -20` 查看堆内存占⽤空间最⼤的前 20 个对象类型。

通过 jmap 命令 dump 出堆内存信息。

```bash
jmap -dump:format=b,file=heap.prof 10025
```

使⽤可视化⼯具分析 dump ⽂件，⽐如说 VisualVM，找到占⽤内存⾼的对象，再找到创建该对象的业务

### 频繁 minor gc 怎么办

频繁的 Minor GC 通常意味着新⽣代中的对象频繁地被垃圾回收，可能是因为新⽣代空间设置的过⼩，或者是因为程序中存在⼤量的短⽣命周期对象（如临时变量）。
可以使⽤ GC ⽇志进⾏分析，查看 GC 的频率和耗时，找到频繁 GC 的原因。

```bash
-XX:+PrintGCDetails -Xloggc:gc.log
```

或者使⽤监控⼯具查看堆内存的使⽤情况，特别是新⽣代（Eden 和 Survivor 区）的使⽤情况。如果是因为新⽣代空间不⾜，可以通过 -Xmn 增加新⽣代的⼤⼩，减缓新⽣代的填满速度。

```bash
java -Xmn256m your-app.jar
```

如果对象需要⻓期存活，但频繁从 Survivor 区晋升到⽼年代，可以通过 -XX:SurvivorRatio 参数调整 Eden 和Survivor 的⽐例。默认⽐例是 8:1，表示 8 个空间⽤于 Eden，1 个空间⽤于 Survivor 区。

```bash
-XX:SurvivorRatio=6
```

调整为 6 的话，会减少 Eden 区的⼤⼩，增加 Survivor 区的⼤⼩，以确保对象在 Survivor 区中存活的时间⾜够⻓，避免过早晋升到⽼年代。

### 频繁 Full GC 怎么办？

频繁的 Full GC 通常意味着⽼年代中的对象频繁地被垃圾回收，可能是因为⽼年代空间设置的过⼩，或者是因为程序中存在⼤量的⻓⽣命周期对象。

```bash
# 查看堆内存各区域的使⽤率以及GC情况
jstat -gcutil -h20 pid 1000
# 查看堆内存中的存活对象，并按空间排序
jmap -histo pid | head -n20
# dump堆内存⽂件
jmap -dump:format=b,file=heap pid
```

或者使⽤⼀些可视化的⼯具，⽐如 VisualVM、JConsole 等，查看堆内存的使⽤情况。

假如是因为⼤对象直接分配到⽼年代导致的 Full GC 频繁，可以通过 -XX:PretenureSizeThreshold 参数设置⼤对象直接进⼊⽼年代的阈值。

或者将⼤对象拆分成⼩对象，减少⼤对象的创建。⽐如说分⻚。

假如是因为内存泄漏导致的频繁 Full GC，可以通过分析堆内存 dump ⽂件找到内存泄漏的对象，再找到内存泄漏的代码位置。

假如是因为⻓⽣命周期的对象进⼊到了⽼年代，要及时释放资源，⽐如说 ThreadLocal、数据库连接、IO 资源等。

假如是因为 GC 参数配置不合理导致的频繁 Full GC，可以通过调整 GC 参数来优化 GC ⾏为。或者直接更换更适合的 GC 收集器，如 G1、ZGC 等。



# 执行系统

## 类加载机制

### 类的⽣命周期

⼀个类从被加载到虚拟机内存中开始，到从内存中卸载，整个⽣命周期需要经过七个阶段：加载 、验证、准备、解析、初始化、使⽤和卸载。

### 类加载过程

- 加载
  - 完成三件事情
    - 通过一个类的全限定名来获取定义此类的二进制字节流。
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    - 在 Java 堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
  - 非数组类型，由类加载器完成加载过程
  - 数组类型，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。数组类的元素类型最终还是要靠类加载器来完成加载。
- 链接
  - 验证：验证文件格式、元数据、字节码和符号引用
  - 准备：为类中定义的变量（即静态变量）分配内存并设置类变量初始值
  - 解析：将常量池内的符号引用替换为直接引用的过程
- 初始化：执行类构造器`<clinit>()`方法的过程。
  - `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。

运行初始化阶段的条件有且只有以下 6 个：

- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段

  - 使用new关键字实例化对象的时候
  - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候
  - 调用一个类型的静态方法的时候

- 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化

- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

- 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解

  析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

- 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 类加载器

#### 类与类加载器

- 启动类加载器
- 扩展类加载器
- 应用程序类加载器
- 自定义类加载器

#### 双亲委派模型

类加载器的双亲委派模型在JDK 1.2时期被引入，并被广泛应用于此后几乎所有的Java程序中，但它并不是一个具有强制性约束力的模型，而是Java设计者们推荐给开发者的一种类加载器实现的最佳实践。

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

为什么要⽤双亲委派模型？

- 避免类的重复加载
- 保证核⼼类库的安全性

#### 破坏双亲委派模型

双亲委派模型的三次“被破坏”：

- 双亲委派模型在1.2 版本被引入之前，可以继承java.lang.ClassLoader 覆盖 loadClass() 实现自定义的类加载器。为了兼容这些已有代码，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。
- 由这个模型自身的缺陷导致的，在某些场景下，启动类加载器需要调用用户的类。例如 SPI，根据双亲委派模型，java.sql.Driver 类应该由⽗加载器加载，但⽗类加载器⽆法加载由⼦类加载器定义的驱动类，如 MySQL 的 com.mysql.cj.jdbc.Driver ，那么只能使⽤ SPI 机制通过 META-INF/services ⽂件指定服务提供者的实现类。

- 是由于用户对程序动态性的追求而导致的，如热部署。




Tomcat 基于双亲委派模型进⾏了⼀些扩展，主要的类加载器有：

- Bootstrap ClassLoader：加载 Java 的核⼼类库；
- Catalina ClassLoader：加载 Tomcat 的核⼼类库；
- Shared ClassLoader：加载共享类库，允许多个 Web 应⽤共享某些类库；
- WebApp ClassLoader：加载 Web 应⽤程序的类库，⽀持多应⽤隔离和优先加载应⽤⾃定义的类库（破坏了双亲委派模型）。

## 字节码执行机制

### 运行时栈帧结构

Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（V irtual MachineStack）的栈元素。一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

# Java 内存模型

## 硬件的效率与一致性

由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

引入了一个新的问题：缓存一致性（Cache Coherence）。

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行重排序。

与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序（Instruction Reorder）优化。

## Java内存模型

Java虚拟机规范定义一种“Java内存模型”屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

### 主内存与工作内存

Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。

此处的变量（V ariables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

Java内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

### 内存间交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。

- lock
- unlock
- read
- load
- use
- assign
- store
- write

将Java内存模型的操作简化为read、write、lock和unlock四种。

### 对于volatile型变量的特殊规则

当一个变量被定义成volatile之后，它将具备两项特性：

- 保证此变量对所有线程的可见性，但是不保证原子性
- 禁止指令重排序优化

### 原子性、可见性与有序性

原子性：

- 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的
- 如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。

可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改

- volatile、synchronized和final

有序性：

- 如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的
  - As-If-Serial
  - “指令重排序”现象和“工作内存与主内存同步延迟”

- volatile和synchronized

### Happens-Before 原则

如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点，这是因为Java语言中有一个“先行发生”（Happens-Before）的原则。

八个原则：

- 