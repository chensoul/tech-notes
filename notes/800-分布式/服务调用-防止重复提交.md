## **1. 前端控制（快速响应，提升体验）**

- **禁用提交按钮**
  用户点击后，按钮置灰或显示加载状态，防止多次点击。

  **缺点**：无法防止用户刷新页面后重新提交或通过工具（如Postman）直接调用接口。

- **前端防抖和节流**

  使用 JavaScript 的防抖（debounce）或节流（throttle）技术，限制用户在短时间内多次触发提交操作。

  **缺点**：这种方法可以有效减少重复提交的可能性，但同样无法防止通过工具（如Postman）直接调用接口。。

- **页面跳转（Post/Redirect/Get, PRG模式）**
  提交后后端返回`302 Redirect`，跳转到结果页，避免刷新时重复提交。
  **流程**：

  1. 用户提交表单 → 2. 服务器处理数据 → 3. 返回重定向到结果页 → 4. 浏览器跳转并显示结果。

  **缺点：**无法防止用户多次点击提交按钮或恶意重复提交

## **2. 令牌机制（Token）**

- **实现步骤**：

  1. **生成Token**：服务器在返回表单时生成唯一Token（如UUID），存储到Session或缓存（如Redis）。
  2. **携带Token**：表单提交时，将Token作为隐藏字段（`<input type="hidden" name="token" value="xxx">`）或请求头发送。
  3. **验证并删除Token**：后端验证Token是否存在且未使用，处理成功后立即删除/标记为失效。

- **代码示例（Java + Redis）**

  ```java
  // 生成Token并存储到Redis
  String token = UUID.randomUUID().toString();
  redisTemplate.opsForValue().set("submit_token:" + token, "1", 5, TimeUnit.MINUTES);
  
  // 验证Token
  if (redisTemplate.delete("submit_token:" + token) == null) {
    throw new RuntimeException("重复提交！");
  }
  ```

## **3. 数据库等性设计**

- **幂等性原理**：同一请求多次执行效果与一次执行相同。

- **实现方式**：

  1. **唯一请求ID**：客户端生成唯一ID（如订单ID），提交时携带该ID。
  2. **检查ID状态**：服务端通过数据库或缓存判断该ID是否已被处理。
  3. **原子性操作**：使用数据库唯一索引或分布式锁（如Redis SETNX）确保并发安全。

- **代码示例（数据库唯一约束）**

  ```sql
  CREATE TABLE orders (
    id VARCHAR(64) PRIMARY KEY, -- 唯一订单号
    ...
  );
  ```

  插入时若重复，数据库抛出异常，后端捕获后返回错误。

## **4. 时间戳/签名验证**

- **限制时间窗口**：请求必须携带时间戳，服务器验证时间差（如5秒内有效）。

  ```java
  long clientTime = request.getParameter("timestamp");
  long serverTime = System.currentTimeMillis();
  if (serverTime - clientTime > 5000) {
    throw new RuntimeException("请求超时");
  }
  ```

- **签名防篡改**：对参数+时间戳+密钥生成签名，服务器校验签名一致性。

## **5. 分布式场景下的全局锁**

- 使用Redis或ZooKeeper实现分布式锁，确保同一请求在集群中仅处理一次。

  ```java
  String lockKey = "submit_lock:" + requestId;
  Boolean locked = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);
  if (!locked) {
    throw new RuntimeException("请勿重复提交");
  }
  ```

## 示例

使用 aop 实现：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface NoRepeatSubmit {
    long expire() default 10; // 默认过期时间10秒
}

@Aspect
@Component
public class NoRepeatSubmitAspect {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Pointcut("@annotation(com.example.annotation.NoRepeatSubmit)")
    public void pointCut() {}

    @Around("pointCut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        NoRepeatSubmit annotation = method.getAnnotation(NoRepeatSubmit.class);
        long expire = annotation.expire();

        // 构建唯一标识
        String key = buildKey(point);

        // 检查是否重复提交
        if (redisTemplate.opsForValue().get(key) != null) {
            throw new RuntimeException("请勿重复提交");
        }

        // 设置锁并执行方法
        redisTemplate.opsForValue().set(key, "1", expire, TimeUnit.SECONDS);
        return point.proceed();
    }

    private String buildKey(ProceedingJoinPoint point) {
        // 构建唯一的 key，可以结合用户ID、方法名等信息
        return "no_repeat_submit:" + point.getSignature().getName();
    }
}
```

使用过滤器实现：

```java
@Component
public class NoRepeatSubmitFilter extends OncePerRequestFilter {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        
        // 检查是否为 POST 请求
        if ("POST".equalsIgnoreCase(request.getMethod())) {
            // 获取请求的唯一标识，可以结合用户ID、请求URI等信息生成
            String requestKey = getRequestKey(request);

            // 检查是否已经存在相同的请求
            if (isRequestExists(requestKey)) {
                // 如果请求已经存在，返回错误信息
                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                response.getWriter().write("请勿重复提交");
                return;
            } else {
                // 如果请求不存在，记录请求
                recordRequest(requestKey);
            }
        }

        // 继续执行后续过滤器
        filterChain.doFilter(request, response);
    }

    private String getRequestKey(HttpServletRequest request) {
        // 示例：使用用户ID和请求URI生成唯一标识
        String userId = request.getHeader("User-Id"); // 假设请求头中包含用户ID
        String uri = request.getRequestURI();
        return userId + ":" + uri;
    }

    private boolean isRequestExists(String requestKey) {
        // 检查 Redis 中是否存在请求标识
        return redisTemplate.opsForValue().get(requestKey) != null;
    }

    private void recordRequest(String requestKey) {
        // 将请求标识存储到 Redis 中，并设置过期时间
        redisTemplate.opsForValue().set(requestKey, "1", 10, TimeUnit.SECONDS);
    }
}
```

## **方案选择建议**

| 场景                   | 推荐方案                            |
| :--------------------- | :---------------------------------- |
| 简单表单提交           | 前端禁用按钮 + PRG模式              |
| 高安全性操作（如支付） | Token + 幂等性设计 + 数据库唯一约束 |
| 分布式API              | 唯一请求ID + 分布式锁 + 幂等性      |

通过组合使用上述方案，可有效防止重复提交，同时兼顾用户体验和系统可靠性。