## 特性



## 原理

1. 内存数据库
   - 高性能读写。数据存储在内存中，访问速度极快，适用于高频次的读写操作。
     - 内存数据结构化存储，避免了磁盘I/O延迟。
     - 使用哈希表、跳表等高效数据结构提升查找效率。
   - 数据持久化机制。
2. 单线程模型，避免了线程切换和竞态产⽣的消耗
   - I/O 多路复用。使用epoll、kqueue等高效的I/O多路复用技术处理大量并发连接。
     - 能够同时监听多个客户端请求并按序处理。
     - 避免了传统多线程模型中的锁竞争问题。
   - 非阻塞网络通信。所有网络通信均采用非阻塞模式，确保单线程高吞吐量。
     - 请求与响应处理分离，避免长时间操作阻塞主线程。
     - 异步任务通过事件驱动实现。

3. 数据同步
   - 主从复制。主节点将数据变化同步给从节点，保证数据一致性。
     - 支持全量复制和增量复制两种方式。
     - 从节点可以作为备份或负载均衡使用。
   - 增量复制与全量复制。
     - 全量复制：初次建立主从关系时，主节点将所有数据发送给从节点。
     - 增量复制：主节点记录操作命令日志，从节点断线重连后仅同步缺失部分。

> 面试题：单机的Redis可以⽀撑每秒⼗万的并发，原因在于：
>
> 1. 完全基于内存操作
>    1. Redis6.0的多线程是⽤多线程来处理数据的读写和协议解析，但是Redis执⾏命令还 是单线程的 。
> 2. 使⽤单线程
>    - **无锁竞争**：核心命令处理采用单线程，避免了多线程上下文切换和锁竞争的开销。
>    - **顺序原子性**：所有操作按顺序原子执行，天然保证线程安全。
>    - **现代CPU单核性能**：单线程可充分利用现代CPU单核性能（3GHz CPU单核每秒可处理3亿条指令）。
> 3. 基于⾮阻塞的IO多路复⽤机制
>    - **epoll/kqueue**：基于操作系统的多路复用机制，单线程可管理数万连接。
>    - **事件驱动**：仅处理活跃连接的事件，避免无效轮询（相比select/poll效率提升显著）。
> 4. 高效数据结构与协议
>    - **优化数据结构**：SDS（动态字符串）、跳跃表、压缩列表等结构实现O(1)/O(logN)时间复杂度。
>    - **二进制安全RESP协议**：简单协议解析仅需线性扫描，无复杂语法解析开销。
> 5. 持久化优化
>    - **异步写入**：RDB快照和AOF重写由子进程执行，主进程无阻塞。
>    - **AOF追加写**：采用追加写入模式（顺序写速度可达400MB/s以上）。
> 6. 系统级优化
>    - **大页内存**：启用透明大页（THP）减少内存管理开销。
>    - **绑核与中断优化**：通过CPU绑核（taskset）和网络中断亲和性（irqbalance）提升缓存命中率。



## 数据结构

String

- 基本介绍：最基本的简直逗结构，支持字符串、整数、浮点数，最大容量 512MB
- 内部实现：int 和 SDS（简单动态字符串）
- 常用指令：SET、GET、INCR、MSEt、SETNX
- 应用场景：
  - 缓存数据：存储用户登录状态、token、配置信息
  - 计数器：访问次数、点赞、转发、库存数量
  - 限速

Hash：

- 基本介绍：Hash 是一个键值对集合。
- 内部实现：由压缩列表或哈希表实现。在 Redis 7.0 中，压缩表数据结构已经废弃，交由 listpack 来实现了。
- 常用命令：HSET、HGET、HMSET、HGETALL、HDEL
- 应用场景：
  - 缓存对象：存储用户信息、对象信息

List：

- 基本介绍：列表类型，⽤来存储多个有序的字符串。按照插入顺序，可以从头部或者尾部向 list 列表添加元素
- 内部实现：3.2 版本之前使用双向链表或压缩列表。3.2 版本之后，只有 qucklist 实现
- 常用命令：LPUSH、LPOP、RPUSH、RPOP、BLPOP、BROP
- 应用场景：
  - 消息队列：生产者通过 LPUSH 添加消息，消防者通过 BRPOP 获取消息
  - 动态列表：存储用户最新动态，通过 LTRIM 控制列表长度
  - 秒杀场景：将秒杀成功的用户写入 list

Set：

- 基本介绍：一个无序并且唯一的集合类型，可以取交集、并集、差集
- 内部实现：由哈希表或者整数集合实现
- 常用命令：SADD、SREM、SCARD
- 应用场景：用户签到、点赞、网站访问统计、抽奖、共同关注、好友推荐等等

ZSet：

- 基本介绍：有序集合，比 Set 类型多了一个排序书写 score，score 可以重复。支持范围查询。
- 内部实现：跳表或者压缩列表。在 7.0 之后，listpack 替代了压缩列表
- 常用命令：ZADD、ZREM、ZCARD、ZSCORE、ZRANGE、ZREVRANGE
- 应用场景：排行榜、时间线等

BitMap：

- 基本介绍：使用二进制位表示状态，占用极小存储空间
- 内部实现：
- 常用命令：SETBIT、GETBIT、BITCOUNT
- 应用场景：统计海量在线用户数量等

HyperLogLog

- 基本介绍：基于概率算法估算基数，误差可控
- 内部实现：
- 常用命令：
- 应用场景：统计在线用户数、签到功能等

## 持久化

### RDB

RDB（快照）。定期将内存中的数据保存到磁盘上，生成RDB文件。

- 触发RDB持久化过程分为⼿动触发和⾃动触发 。
  - 手动触发：
    - save命令：阻塞当前Redis服务器，直到RDB过程完成为⽌，对于内存⽐较⼤的实例会造成长时间阻 塞，线上环境不 建议使⽤。
    - bgsave命令：Redis进 程执⾏fork操作创建⼦进 程，RDB持久化过程由⼦进程负责，完成后⾃动结束。阻塞只发⽣在fork阶段，⼀般时间很短。
  - 自动触发：
    - 使⽤save相关配置， 如“save m n”。 表⽰m秒内数据集存在n次修改时 ，⾃动触发bgsave。
    - 如果从节点执⾏全量复制操作 ，主节点⾃动执⾏bgsave⽣成RDB⽂件并发送给从节点
    - 执⾏debug reload命令重新加载Redis时，也会⾃动触发save操作
    - 默认情况下执⾏shutdown命令时，如果没有开启AOF持久化功能则⾃动执⾏bgsave
- 优点：
  - 只有⼀个紧凑的⼆进制⽂件 dump.rdb ，⾮常适合备 份、全量复制的场景。
  - 容灾性好，可以把RDB⽂件拷贝到远程机器或者⽂件系统张，⽤于容灾恢复。
  - 恢复速度快，RDB恢复数据的速度远远快于AOF的⽅式
- 缺点：
  - 实时性低，RDB 是间隔⼀段时间进⾏持久化，没法做到实时持久化/秒级持久化。 如果在这⼀间隔事件发⽣故障，数据会丢失。
  - 存在兼容问题，Redis演进过程存在多个格式的RDB版本，存在⽼版本Redis⽆法兼容新版本RDB的问题 。

### AOF

AOF（追加日志）。每次写操作都会记录到AOF文件中，支持增量重放。

- ⼯作流程操作 ：命令写⼊ （append）、⽂件同步（sync）、⽂件重写 （rewrite） 、重启加载（load）
  - 所有的写⼊命令会追加到aof_buf（ 缓冲区）中。
  - AOF缓冲区根据对应的策略向硬盘做同步操作 。
  - 随着AOF⽂件越来越⼤ ，需要定期对AOF⽂件进⾏重写，达到压缩的⽬的 。
  - 当Redis服务器重启时，可以加载AOF⽂件进⾏数据恢复。
- 支持三种同步策略：always、everysec、no。
- 优点：
  - 实时性好，aof 持久化可以配置 appendfsync 属性，有 always ，每 进⾏⼀次命令操作就记录到 aof ⽂件中⼀次。
  - 通过 append 模式写⽂件，即使中途服务器宕机，可以通过 redis-check-aof ⼯具解决数据⼀致性问题 。
- 缺点：
  - AOF ⽂件⽐ RDB ⽂件⼤， 且恢复速度慢。
  - 数据集⼤的时候，⽐ RDB 启动效率低。

### 混合持久化

Redis 4.0 版本，将 rdb ⽂件的内容和增量的 AOF ⽇志⽂件存在⼀起。 这⾥的 AOF ⽇志不再是全量的⽇志，⽽是⾃持久化开始到持久化结束 的 这段时间发⽣的增量 AOF ⽇志，通常这部分 AOF ⽇志很⼩。于是在 Redis 重 启的时候，可以先加载 rdb 的内容， 然后再重放增量 AOF ⽇志就可以完全替代之前的 AOF 全量⽂件重放 ，重启效率因此⼤幅得到提升。

## 高可用

### 主从复制

主从复制， 是指将⼀台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点(master)，后者称为从节点(slave)，且数据的复制是单向的 ，只能由主节点到从节点 。Redis 主从复制⽀持主从同步和从从同步两种 ，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。

主从复制主要的作⽤?

- 数据冗余： 主从复制实现了数据的热备份，是持久化之外的⼀种数据冗 余⽅式。
- 故障恢复： 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 (实际上是⼀种服务的冗余)。
- 负载均衡： 在主从复制的基础上，配合读写分离，可以由主节点提供写服务 ，由从节点提供读服务 （即写 Redis 数据时应⽤连接主节点，读 Redis 数据时应⽤连接从节点 ），分担服务器负载 。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以⼤⼤提⾼ Redis 服务器的并发量 。
- ⾼可⽤基⽯： 除了上述作⽤以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis ⾼可⽤的基础。

Redis的复制拓扑结构可以⽀持单层或多层复制关系 ，根据拓扑复杂性可以分为以下三种：⼀主⼀从、⼀主多从、树状主从结构。

主从复制虽好 ，但也存在⼀些问题 ：

- ⼀旦主节点出现故障，需要⼿动将⼀个从节点晋升为主节点，同时需要修改应⽤⽅的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要⼈⼯⼲预。
- 主节点的写能⼒受到单机的限制。
- 主节点的存储能⼒受到单机的限制。

第⼀个问题是Redis的⾼可⽤问题 ，第⼆、三个问题属于Redis的分布式问题 。

### 哨兵模式

主从复制存在⼀个问题 ，没法完成⾃动故障转移。所以我们需要⼀个⽅案来完成⾃动故障转移， 它就是Redis Sentinel（哨兵） 。

Redis Sentinel ， 它由两部分组成，哨兵节点和数据节点 ：

- 哨兵节点： 哨 兵系统由⼀个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进⾏监控。
- 数据节点： 主节点和从节点都是数据节点；

### 集群模式

## 缓存设计

### 缓存雪崩、穿透、击穿

缓存雪崩：大量缓存数据**同时失效**或 Redis 服务宕机，导致所有请求直接访问数据库，引发数据库压力激增甚至崩溃。

- 解决办法：
  - 分散过期时间：为每个 Key 添加随机值（如基础过期时间 + 随机 1-5 分钟）
  - 集群高可用：使用 Redis Cluster 或主从复制（Sentinel），避免单点故障
  - 持久化与快速恢复：启用 RDB/AOF 持久化，故障后快速重建缓存。
  - 限流降级：使用熔断器限制数据库访问流量。
  - 多级缓存：结合本地缓存（Caffeine）和分布式缓存（Redis），减少穿透风险

缓存穿透：频繁查询**不存在的数据**（如恶意攻击），绕过缓存直接访问数据库。

- 解决办法：
  - **缓存空对象（Null Caching）**：对不存在的数据缓存空值，并设置短过期时间（如 5 分钟）
  - **布隆过滤器（Bloom Filter）**：前置过滤器拦截非法请求，判断数据是否存在。
  - **请求校验**：拦截非法参数（如非数字ID、越界值）。

缓存击穿：某个**热点 Key 突然失效**，导致高并发请求直接冲击数据库。

- 解决办法：

  - **互斥锁（Mutex Lock）**：仅允许一个线程重建缓存，其他线程等待。

  - **逻辑过期（Logical Expiration）**：缓存永不过期，但存储逻辑过期时间，异步更新数据。

  - **热点数据永不过期**：不设置 TTL，通过定时任务或更新事件主动刷新缓存。

    

## 运维

慢查询：

```sql
slowlog get
```



## 应用

redis 的使用技巧：

- 限流时，只查询 mysql，不查询数据库
- 两个集群互为备份。需要考虑心跳检测、流量控制问题，不考虑数据同步。
  - 低配集群作为备份
  - 本地集群容错云服务
  - 跨云容错
  - 业务集群互为备份
- 双活架构。
- JSON 转成 Hash 进行存储。Redis 6 如何进行 json 操作
- zset 实现榜单 + 本地缓存
  - 定时任务计算全局的1000名，假设每个小时计算一次。那么即便有突发热点，那么最多一个小时就能看出来；
  - 将1000名定时写入到 Redis，**用 zset 实时维护**。写入的时候删除原有的key然后将1000名写入。这一步是为了尽可能保证榜单数据准确
  - 再起一个定时任务，每一分钟将redis中的前100名（也就是1000中的前100，有可能不是全局的前100）同步到所有节点的本地缓存上，这一步是为了访问效率
  - 从本地读取榜单数据

- zset 实现榜单 + 本地缓存，key 拆分

- Redis中优化大Hash结构、大 key

- 使用 List 来限流

  ```lua
  local key = KEYS[1]
  local limit = tonumber(ARGV[1])
  -- 假设 window 是毫秒表达的
  local window = tonumber(ARGV[2])
  -- 当前时间戳我们要求服务端传过来，因为本质上这个窗口描述的是服务端，
  -- 只是借助了 Redis 来实现，同样是毫秒表达
  local now = tonumber(ARGV[3])
  -- 窗口的最小时间，时间小于这个，就说明已经不在窗口内了
  local windowStart = now - window
  
  
  -- 获得 list 的长度
  local len = tonumber(redis.call('LLEN', key))
  -- 这是一个小优化，避免每个请求都触发淘汰
  if(len >= limit) then
      -- list 满了，现在要淘汰了
      local head = tonumber(redis.call('LPOP', key))
      while head <= windowStart do
          head = tonumber(redis.call('LPOP', key))
      end
      -- 说明当前的 head 还在窗口内，放回去
      redis.call('LPUSH', key, head)
      -- 看看淘汰不在窗口内请求之后，还有多少个
      -- 实际上你可以在 while 循环里面手动维护 len
      -- 我这里为了可读性就再次调用了 LLEN
      len = tonumber(redis.call('LLEN', key))
  end
  
  if(len < limit) then
      -- 插入这个请求的时间戳
      redis.call('RPUSH', key, now)
      redis.call('PEXPIRE', key, window)
      -- 允许
      return 1
  end
  -- 说明超过阈值了
  return 0
  ```

  

### 异步队列

### 延时队列

### 事务

### 管道

### 分布式锁

## 底层结构

## 参考

黑马程序员 Redis 入门到实战教程 官方的文档 《Redis 入门指南（第 2 版）》 《Redis 使用手册》 【尚硅谷】Redis 6 入门到精通 Redis 开发与运维 《Redis 实战》 《Redis 设计与实现》 极客时间《Redis 源码剖析与实战》 说透 Redis 7