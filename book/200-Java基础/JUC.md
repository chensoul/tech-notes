## CAS

由于JVM的synchronized重量级锁涉及操作系统 （如Linux） 内核态下的互斥锁的使用， 其线程阻塞和唤醒都涉及进程在用户态和到内核态的频繁切换，导致重量级锁开销大、性能低。而JVM的synchronized轻量级锁使用CAS（Compare And Swap，比较并交换）进行自旋抢锁，CAS是CPU指令级的原子操作并处于用户态下，所以JVM轻量级锁开销较小。

### CAS 原理

JDK 5所增加的JUC （java.util.concurrent） 并发包对操作系统的底层CAS原子操作进行了封装，为上层Java程序提供了CAS操作的API。

#### Unsafe 类中的 CAS 方法

Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等，Unsafe大量的方法都是原生（native）方法，基于C++语言实现，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。

Unsafe类的全限定名为sun.misc.Unsafe，从名字中我们可以看出这个类对普通程序员来说是“危险”的，一般的应用开发都不会涉及此类，Java官方也不建议直接在应用程序中使用。

> 为什么此类取名为Unsafe呢？由于使用Unsafe类可以像C语言一样使用指针操作内存空间，这无疑增加了指针相关问题、内存泄漏问题的出现概率。总之，在程序中过度使用Unsafe类会使得程序出错的概率变大，使得安全的语言Java变得不再“安全”，因此对Unsafe的使用一定要慎重。

操作系统层面的CAS是一条CPU的原子指令 （cmpxchg指令） ， 正是由于该指令具备了原子性，因此使用CAS操作数据时不会造成数据不一致的问题，Unsafe提供的CAS方法直接通过native方式（封装C++代码）调用了底层的CPU指令cmpxchg。

#### 使用 CAS 进行无锁编程

CAS是一种无锁算法，该算法关键依赖两个值——期望值（就值）和新值，底层CPU利用原子操作判断内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。

使用CAS进行无锁编程的步骤大致如下：

1）获得字段的期望值（oldValue）。

2）计算出需要替换的新值（newValue）。

3） 通过CAS将新值 （newValue） 放在字段的内存地址上， 如果CAS失败就重复第1） 步到第2）步，直到CAS成功，这种重复俗称CAS自旋。

当并发修改的线程少， 冲突出现的机会少时， 自旋的次数也会很少， CAS性能会很高；当并发修改的线程多，冲突出现的机会多时，自旋的次数也会很多，CAS性能会大大降低。所以，提升CAS无锁编程效率的关键在于减少冲突的机会。

### JUC 原子类

JUC并发包中原子类都存放在java.util.concurrent.atomic类路径下

基础原子类（以AtomicInteger为例）主要通过CAS自旋+volatile相结合的方案实现，既保障了变量操作的线程安全性，又避免了synchronized重量级锁的高开销，使得Java程序的执行效率大为提升。

> CAS用于保障变量操作的原子性，volatile关键字用于保障变量的可见性，二者常常结合使用。

#### ABA 问题

什么是ABA问题？举一个例子来说明。 比如一个线程A从内存位置M中取出V1， 另一个线程B也取出V1。现在假设线程B进行了一些操作之后将M位置的数据V1变成了V2，然后又在一些操作之后将V2变成V1。之后，线程A进行CAS操作，但是线程A发现M位置的数据仍然是V1，最后线程A操作成功。尽管线程A的CAS操作成功，但是不代表这个过程是没有问题的，线程A操作的数据V1可能已经不是之前的V1，而是被线程B替换过的V1，这就是ABA问题。



很多乐观锁的实现版本都是使用版本号（Version）方式来解决ABA问题。乐观锁每次在执行数据的修改操作时都会带上一个版本号， 版本号和数据的版本号一致就可以执行修改操作并对版本号执行加1操作，否则执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。



参考乐观锁的版本号，JDK提供了一个类似 AtomicStampedReference类来解决ABA问题。AtomicStampReference在CAS的基础上增加了一个Stamp（印戳或标记），使用这个印戳可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验。



AtomicMarkableReference是AtomicStampedReference的简化版，不关心修改过几次，仅仅关心是否修改过。因此，其标记属性mark是boolean类型，而不是数字类型，标记属性mark仅记录值是否修改过。

AtomicMarkableReference适用于只要知道对象是否被修改过的场景，而不适用于对象被反复修改的场景。

### 提升高并发场景下 CAS 操作的性能

在争用激烈的场景下，会导致大量的CAS空自旋。比如，在大量的线程同时并发修改一个AtomicInteger时，可能有很多线程会不停地自旋，甚至有的线程会进入一个无限重复的循环中。大量的CAS空自旋会浪费大量的CPU资源，大大降低了程序的性能。

在高并发场景下如何提升CAS操作性能呢？可以使用LongAdder替代AtomicInteger。

Java 8提供一个新的类LongAdder，以空间换时间的方式提升高并发场景下CAS操作性能。

LongAdder核心思想就是热点分离，与ConcurrentHashMap的设计思想类似：将value值分离成一个数组，当多线程访问时，通过Hash算法将线程映射到数组的一个元素进行操作；而获取最终的value结果时，则将数组的元素求和。

最终， 通过LongAdder将内部操作对象从单个value值 “演变” 成一系列的数组元素， 从而减小了内部竞争的粒度。



AtomicLong使用内部变量value保存着实际的long值，所有的操作都是针对该value变量进行。也就是说， 在高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。重试线程越多，就意味着CAS的失败概率越高，从而进入恶性CAS空自旋状态。

LongAdder的基本思路就是分散热点， 将value值分散到一个数组中， 不同线程会命中到数组的不同槽（元素）中，各个线程只对自己槽中的那个值进行CAS操作。这样热点就被分散了，冲突的概率就小很多。

使用LongAdder，即使线程数再多也不担心，各个线程会分配到多个元素上去更新，增加元素个数就可以降低 value的“热度”，AtomicLong中的恶性CAS空自旋就解决了。

### CAS 在 JDK 中的广泛应用

CAS的优势主要有两点：

1）属于无锁编程，线程不存在阻塞和唤醒这些重量级的操作。

2）进程不存在用户态和内核态之间的运行切换，进程不需要承担频繁切换的开销。

CAS操作的弊端主要有以下4点。

（1）ABA问题

（2）只能保证一个共享变量之间的原子性操作

（3）无效CAS会带来开销问题

（4）在部分CPU平台上存在“总线风暴”问题

CAS操作和volatile一样也需要CPU进行通过MESI协议各个内核的“Cache一致性”，会通过CPU的BUS（总线）发送大量MESI协议相关的消息，产生“Cache一致性流量”。因为总线被设计为固定的 “通信能力”， 如果Cache一致性流量过大， 总线将成为瓶颈， 这就是所谓的 “总线风暴”。



提升CAS性能有效方式之一是以空间换时间，分散竞争热点。较为常见的方案为：

1）分散操作热点，使用LongAdder替代基础原子类AtomicLong，LongAdder将单个CAS热点（value值）分散到一个cells数组中。

2）使用队列削峰，将发生CAS争用的线程加入一个队列中排队，降低CAS争用的激烈程度。JUC中非常重要的基础类AQS（抽象队列同步器）就是这么做的。

提升CAS性能有效方式之二是使用线程本地变量，从根本上避免竞争。



## JUC

前面介绍的在争用激烈的场景下，使用基于CAS自旋实现的轻量级锁有两个大的问题：

1）CAS恶性空自旋会浪费大量的CPU资源。

2）在SMP架构的CPU上会导致“总线风暴”。

解决CAS恶性空自旋的有效方式之一是以空间换时间，较为常见的方案有两种：分散操作热点、使用队列削峰。JUC并发包使用的是队列削峰的方案解决CAS的性能问题，并提供了一个基于双向队列的削峰基类——抽象基础类AbstractQueuedSynchronizer（抽象同步器类，简称为AQS）。



### 锁与队列的关系

无论是单体服务应用内部的锁，还是分布式环境下多体服务应用所使用的分布式锁，为了减少由于无效争夺导致的资源浪费和性能恶化，一般都基于队列进行排队与削峰。

1. CLH 锁的内部队列

CLH自旋锁使用的CLH（Craig, Landin, and Hagersten Lock Queue）是一个单向队列，也是一个FIFO队列。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；队列的队首节点 （队列的头部） 表示占有锁的节点， 新加入的抢锁线程则需要等待， 会插入到队列的尾部。

2. 分布式锁的内部队列

在分布式锁的实现中，比较常见的也是基于队列的方式进行不同节点中“等锁线程”的统一调度和管理。

3. AQS 的内部队列

AQS是JUC提供的一个用于构建锁和同步容器的基础类。 JUC包内的许多类都是基于AQS构建，例如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。

AQS是CLH队列的一个变种，主要原理和CLH队列差不多。AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针， 分别指向直接的前驱节点和直接的后驱节点。 所以双向链表可以从任意一个节点开始很方便地访问前驱节点和后驱节点。 每个节点其实是由线程封装的， 当线程争抢锁失败后会封装成Node加入到AQS队列中去；当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点（线程）。

### JUC 显式锁与 AQS 的关系

AQS是java.util.concurrent包的一个同步器， 它实现了锁的基本抽象功能， 支持独占锁与共享锁两种方式。 该类使用模板模式来实现的， 成为构建锁和同步器的框架， 使用该类可以简单且高效地构造出应用广泛的同步器（或者等待队列）。

java.util.concurrent.locks包中的显式锁如ReentrantLock、ReentrantReadWriteLock，线程同步工具如Semaphore，异步回调工具如FutureTask等，内部都使用了AQS作为等待队列。

### JUC 显示锁

与Java内置锁不同，JUC显式锁提供了一种非常灵活的、使用纯Java语言基本的锁，这种锁的使用非常灵活，可以进行无条件的、可轮询的、定时的、可中断的锁获取和释放操作。由于JUC锁的加锁和解锁的方法都是通过Java API显式进行的，所以也叫显式锁。



使用Java内置锁时，不需要通过Java代码显式地对同步对象的监视器进行抢占和释放，这些工作由JVM底层完成，而且任何一个Java对象都能作为一个内置锁使用，所以，Java的对象锁使用起来非常方便。但是，Java内置锁的功能相对单一，不具备一些比较高级的锁功能，比如：

1）限时抢锁：在抢锁时设置超时时长，如果超时还未获得锁就放弃，不至于无限等下去。

2） 可中断抢锁： 在抢锁时， 外部线程给抢锁线程发出一个中断信号， 就能唤起等待锁的线程，并终止抢占过程。

3）多个等待队列：为锁维持多个等待队列，以便提高锁的效率。比如在生产者－消费者模式实现中， 生产者和消费者共用一把锁， 该锁上维持两个等待队列， 即一个生产者队列和一个消费者队列。

除了以上功能问题之外，Java对象锁还存在性能问题。在竞争稍微激烈的情况下，Java对象锁会膨胀为重量级锁 （基于操作系统的Mutex Lock实现） ， 而重量级锁的线程阻塞和唤醒操作需要进程在内核态和用户态之间来回切换， 导致其性能非常低。 所以， 迫切需要提供一种新的锁来提升争用激烈场景下锁的性能。

Java显式锁就是为了解决这些Java对象锁的功能问题、 性能问题而生的。 JDK 5版本引入了Lock接口，Lock是Java代码级别的锁。为了与Java对象锁相区分，Lock接口被称为显式锁接口，其对象实例则被称为显式锁对象。

#### 显式锁 Lock 接口

JDK 5版本引入了java.util.concurrent并发包，简称为JUC包，里面提供了各种高并发工具类，通过此JUC工具包可以在Java代码中实现功能非常强大的多线程并发操作。所以，Java显式锁也被称为JUC显式锁。

Lock接口位于java.util.concurrent.locks包中，是JUC显式锁的一个抽象JUC包中提供了一系列的显式锁实现类 （如ReentrantLock） ， 当然也允许应用程序提供自定义的锁实现类。

与synchronized关键字不同，显式锁不再作为Java内置特性来实现，而是作为Java语言可编程特性来实现。 这就为多种不同功能的锁实现留下了空间， 各种锁实现可能有不同的调度算法、 性能特性或者锁定语义。

从Lock提供的接口方法可以看出，显式锁至少比Java内置锁多了以下优势：

（1）可中断获取锁

使用synchronized关键字获取锁的时候，如果线程没有获取到被阻塞，阻塞期间该线程是不响应中断信号（interrupt）的；而使用Lock.lockInterruptibly()方法获取锁时，如果线程被中断，线程将抛出中断异常。

（2）可非阻塞获取锁

使用synchronized关键字获取锁时， 如果没有成功获取， 线程只有被阻塞； 而使用Lock.tryLock()方法获取锁时，如果没有获取成功，线程也不会被阻塞，而是直接返回false。

（3）可限时抢锁

使用Lock.tryLock(long time, TimeUnit unit)方法，显式锁可以设置限定抢占锁的超时时间。而在使用synchronized关键字获取锁时，如果不能抢到锁，线程只能无限制阻塞。

除了以上能通过Lock接口直接观察出来的三点优势之外，显式锁还有不少其他的优势。

#### 可重入锁 ReentrantLock

ReentrantLock是JUC包提供的显式锁的一个基础实现类， ReentrantLock类实现了Lock接口， 它拥有与synchronized相同的并发性和内存语义，但是拥有了限时抢占、可中断抢占等一些高级锁特性。此外，ReentrantLock基于内置的抽象队列同步器（Abstract Queued Synchronized，AQS）实现，在争用激烈场景下，能表现出表内置锁更佳的性能。

ReentrantLock是一个可重入的独占（或互斥）锁，其中两个修饰词的含义为：

1）可重入的含义：表示该锁能够支持一个线程对资源的重复加锁，也就是说，一个线程可以多次进入同一个锁所同步的临界区代码块。 比如， 同一线程在外层函数获得锁后， 在内层函数能再次获取该锁，甚至多次抢占到同一把锁。

2）独占的含义：在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能等待，只有拥有锁的线程释放了锁后，其他的线程才能够获取锁。

分离变与不变是软件设计的一个基本原则。



通常情况下，大家会使用lock()方法进行阻塞式的锁抢占，其模板代码如下：

```java
//创建所对象，SomeLock为Lock的某个实现类，如ReentrantLock
Lock lock = new SomeLock();
lock.lock(); //step1：抢占锁

try {
	//step2：抢锁成功，执行临界区代码
} finally {
	lock.unlock(); //step3：释放锁

}
```

调用tryLock()方法非阻塞抢占锁：

```java
//创建所对象，SomeLock为Lock的某个实现类，如ReentrantLock
Lock lock = new SomeLock();
if (lock.tryLock()) { //step1：尝试抢占锁
  try {
    //step2：抢锁成功，执行临界区代码
  } finally {
  	lock.unlock(); //step3：释放锁
  }
}
else{
	//step4：抢锁失败，执行后备动作
}
```

调用tryLock(long time, TimeUnit unit)方法限时抢锁，其大致的代码模板如下：

```java
//创建所对象，SomeLock为Lock的某个实现类，如ReentrantLock
Lock lock = new SomeLock();
//抢锁时阻塞一段时间，如1秒
if (lock.tryLock(1, TimeUnit.SECONDS)) { //step1：限时阻塞抢占
  try {
  	//step2：抢锁成功，执行临界区代码
  } finally {
  	lock.unlock(); //step3：释放锁
  }
}
else{
	//限时抢锁失败，执行后备动作
}
```

对lock()、tryLock()、tryLock(long time, TimeUnit unit)这三个方法的总结如下：

1）lock()方法用于阻塞抢锁，抢不到锁时线程会一直阻塞。

2）tryLock()方法用于尝试抢锁，该方法有返回值，如果成功则返回true，如果失败（即锁已被其他线程获取） 则返回false。 此方法无论如何都会立即返回， 在抢不到锁时， 线程不会像使用lock()方法那样一直被阻塞。

3）tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过这个方法在抢不到锁时会阻塞一段时间。如果在阻塞期间获取到锁立即返回true，超时则返回false。

#### 基于显式锁进行“等待－通知”方式的线程间通信

在前面介绍Java的线程间通信机制时，基于Java内置锁实现一种简单的“等待－通知”方式的线程间通信：通过Object对象的wait、notify两类方法作为开关信号，用来完成通知方线程和等待方线程之间的通信。

与Object对象的wait()、notify()两类方法类似，基于Lock显式锁JUC也为大家提供了一个用于线程间进行“等待－通知”方式通信的接口——java.util.concurrent.locks.Condition。

await（系列）方法对应于Object.wait()方法，signal()方法对应于Object.notify()方法，signalAll()方法对应于Object.notifyAll()方法。

#### LockSupport

LockSupport是JUC提供的一线程阻塞与唤醒的工具类，该工具类可以让线程在任意位置阻塞和唤醒，其所有的方法都是静态方法。

LockSupport的方法主要有两类：park和unpark。park英文意思为停车，如果把Thread看成一辆车的话，park()方法就是让车停下，其作用是将调用park()的当前线程阻塞；而unpark()方法就是让车启动，然后跑起来，其作用是将指定线程Thread唤醒。



从功能上说， LockSupport.park()与Thread.sleep()方法类似， 都是让线程阻塞， 二者的区别如下：

1）Thread.sleep()没法从外部唤醒，只能自己醒过来；而被LockSupport.park()方法阻塞的线程可以通过调用LockSupport.unpark()方法去唤醒。

2） Thread.sleep()方法声明了InterruptedException中断异常， 这是一个受检异常， 调用者需要捕获这个异常或者再抛出；而使用LockSupport.park()方法时不需要捕获中断异常。

3）被LockSupport.park()方法、Thread.sleep()方法所阻塞的线程有一个特点，当被阻塞线程的Thread.interrupt()方法调用时，被阻塞线程都会响应线程的中断信号，唤醒线程的执行。不同的是，二者对中断信号的响应方式不同：LockSupport.park()方法不会抛出InterruptedException异常，仅仅设置了线程的中断标志；而Thread.sleep()方法还会抛出InterruptedException异常。

4） 与Thread.sleep()相比，调用LockSupport.park()能更精准、更加灵活地阻塞、唤醒指定线程。

5）Thread.sleep()本身就是一个原生（native）方法；LockSupport.park()并不是一个原生方法，只是调用了一个Unsafe类的原生方法（名字也叫park）去实现。

6） LockSupport.park()方法还允许设置一个Blocker对象， 主要用来供监视工具或诊断工具确定线程受阻塞的原因。

> 通过Thread.sleep()方法进入阻塞的线程不会释放持有的锁， 因此在持有锁的时候调用该方法需要谨慎。 那么通过LockSupport.park()方法进入阻塞的线程， 会不会释放所持有的锁呢？当然也不会。

从功能上说，LockSupport.park()与Object.wait()方法也类似，都是让线程阻塞，二者的区别如下：

1） Object.wait()方法需要在synchronized块中执行， 而LockSupport.park()可以在任意地方执行。

2） 当被阻塞线程中断时， Object.wait()方法抛出了中断异常， 调用者需要捕获或者再抛出； 当被阻塞线程中断时，LockSupport.park()不会抛出异常，调用时不需要处理中断异常。

#### 显式锁的分类

显式锁有很多种，从不同的角度来看，显式锁大概有以下几种分类：可重入锁与不可重入锁、悲观锁和乐观锁、公平锁和非公平锁、共享锁和独占锁、可中断锁和不可中断锁。

1. 可重入锁与不可重入锁

从同一个线程是否可以重复占有同一个锁对象的角度来分，显式锁可以分为可重入锁与不可重入锁。

可重入锁也被称为递归锁， 指的是一个线程可以多次抢占同一个锁。 例如， 线程A在进入外层函数抢占了一个Lock显式锁之后， 当线程A继续进入内层函数时， 如果遇到有抢占同一个Lock显式锁的代码，线程A依然可以抢到该Lock显式锁。

不可重入锁与可重入锁相反， 指的是一个线程只能抢占一次同一个锁。 例如， 线程A在进入外层函数抢占了一个Lock显式锁之后，当线程A继续进入内层函数时，如果遇到有抢占同一个Lock显式锁的代码，线程A不可以抢到该Lock显式锁。除非线程A提前释放了该Lock显式锁，才能第二次抢占该锁。

JUC的ReentrantLock类是可重入锁的一个标准实现类。

2. 悲观锁和乐观锁

从线程进入临界区前是否锁住同步资源的角度来分，显式锁可以分为悲观锁和乐观锁。悲观锁就是悲观思想，每次去入临界区操作数据的时候都认为别的线程会修改，所以线程每次在读写数据时都会上锁， 锁住同步资源， 这样其他线程需要读写这个数据时就会阻塞，一直等到拿到锁。总体来说，悲观锁适用于写多读少的场景，遇到高并发写的可能性高。

Java的Synchronized重量级锁是一种悲观锁。

乐观锁是一种乐观思想，每次去拿数据的时候都认为别的线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作 （比较跟上一次的版本号， 如果一样就更新） ， 如果失败就要重复读-比较-写的操作。总体来说，乐观锁适用于读多写少的场景，遇到高并发写的可能性低。

Java中的乐观锁基本都是通过CAS自旋操作实现的。 CAS是一种更新原子操作， 比较当前值跟传入值是否一样，是则更新，不是则失败。在争用激烈的场景下，CAS自旋会出现大量的空自旋，会导致乐观锁性能大大降低。

Java的Synchronized轻量级锁是一种乐观锁。另外，JUC中基于抽象队列同步器（AQS）实现的显式锁（如ReentrantLock）都是乐观锁。

> 既然在争用激烈的场景下乐观锁的性能非常低， 那么为什么JUC的显式锁都是乐观锁呢？根本的原因是，JUC的显式锁都是基于AQS实现的，而AQS通过对队列的使用很大程度上减少了锁的争用，极大地减少了空的CAS自旋。所以，即使在争用激烈场景下，基于AQS的JUC乐观锁也能表现出比悲观锁更佳的性能。

3. 公平锁和非公平锁

公平锁是指不同的线程抢占锁的机会是公平的、平等的，从抢占时间上来说，先对锁进行抢占的线程一定被先满足，抢锁成功的次序体现为FIFO（先进先出）顺序。简单来说，公平锁就是保障了各个线程获取锁都是按照顺序来的，先到的线程先获取锁。

使用公平锁，比如线程A、B、C、D依次去获取锁，线程A首先获取到了锁，然后它处理完成释放锁之后，会唤醒下一个线程B去获取锁。后续不断重复前面的过程，线程C、D依次获取锁。

非公平锁是指不同的线程抢占锁的机会是非公平的、不平等的，从抢占时间上来说，先对锁进行抢占的线程不一定被先满足，抢锁成功的次序不会体现为FIFO（先进先出）顺序。

使用公平锁，比如线程A、B、C、D依次去获取锁, 假如此时持有锁的是线程A，然后线程B、C、 D尝试获取锁， 就会进入一个等待队列。 当线程A释放掉锁之后， 会唤醒下一个线程B去获取锁。

在唤醒线程B的这个过程中， 如果有别的线程E尝试去请求锁， 那么线程E是可以先获取到的， 这就是插队。为什么线程E可以插队呢？因为CPU唤醒线程B需要进行线程的上下文切换，这个操作需要一定的时间，线程E可能与线程A、B不在同一个CPU内核上执行，而是在其他的内核上执行，所以不需要进行线程的上下文切换。在线程A释放锁和线程B被唤醒的这段时间，锁是空闲的，其他内核上的线程E此时就能趁机获取非公平锁，这样做的目的主要是利用锁的空档期，提高其利用效率。

默认情况下，ReentrantLock实例是非公平锁，但是，如果在实例构造时传入了参数true，所得到的锁就是公平锁。另外，ReentrantLock的tryLock()方法是一个特例，一旦有线程释放了锁，正在tryLock的线程就能优先取到锁，即使已经有其他线程在等待队列中。

4. 可中断锁和不可中断锁

什么是可中断锁？如果某一线程A正占有锁在执行临界区代码，另一线程B正在阻塞式抢占锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己的阻塞等待，这种就是可中断锁。

什么是不可中断锁？一旦这个锁被其他线程占有，如果自己还想抢占，自己只能选择等待或者阻塞， 直到别的线程释放这个锁， 如果别的线程永远不释放锁， 那么自己只能永远等下去， 并且没有办法终止等待或阻塞。

简单来说，在抢锁过程中能通过某些方法去终止抢占过程，这就是可中断锁，否则就是不可中断锁。

Java的synchronized内置锁就是一个不可中断锁， 而JUC的显式锁 （如ReentrantLock） 是一个可中断锁。

5. 独占锁和共享锁

独占锁指的是每次只有一个线程能持有的锁。独占锁是一种悲观保守的加锁策略，它不必要地限制了读/读竞争，如果某个只读线程获取锁，那么其他的读线程都只能等待，这种情况下就限制了读操作的并发性，因为读操作并不会影响数据的一致性。

JUC的ReentrantLock类是一个标准的独占锁实现类。共享锁允许多个线程同时获取锁，容许线程并发进入临界区。与独占锁不同，共享锁是一种乐观锁，它放宽了加锁策略，并不限制读/读竞争，允许多个执行读操作的线程同时访问共享资源。

JUC的ReentrantReadWriteLock（读写锁）类是一个共享锁实现类。使用该读写锁时，读操作可以有很多线程一起读， 但是写操作只能有一个线程去写， 而且在写入的时候， 别的线程也不能进行读的操作。

用ReentrantLock锁替代ReentrantReadWriteLock锁虽然可以保证线程安全，但是也会浪费一部分资源，因为多个读操作并没有线程安全问题，所以在读的地方使用读锁，在写的地方使用写锁，可以提高程序执行效率。

#### 悲观锁和乐观锁

Java的synchronized是悲观锁， 悲观锁可以确保无论哪个线程持有锁， 都能独占式访问临界区。虽然悲观锁的逻辑非常简单，但是存在不少问题。

##### 悲观锁存在的问题

悲观锁总是假设会发生最坏的情况，每次线程去读取数据时，也会上锁。这样其他线程在读取数据时就会被阻塞，直到它拿到锁。传统的关系型数据库用到了很多悲观锁，比如行锁、表锁、读锁、写锁等。

悲观锁机制存在以下问题：

1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。

2）一个线程持有锁后，会导致其他所有抢占此锁的线程挂起。

3）如果一个优先级高的线程等待一个优先级低的线程释放锁，就会导致线程的优先级倒置，从而引发性能风险。

解决以上悲观锁的这些问题的有效方式是使用乐观锁去替代悲观锁。 乐观锁其实是一种思想。在使用乐观锁时， 每次线程去读取数据时都认为其他线程不会修改， 所以不会上锁， 仅仅在更新时会判断一下其他线程有没有去更新这个数据。 数据库操作中的带版本号数据更新、 JUC包的原子类都使用了乐观锁的方式提高性能。

##### 通过 CAS 实现乐观锁

乐观锁的操作主要就是两个步骤：

1）第一步：冲突检测。

2）第二步：数据更新。

乐观锁的一种比较典型的就是CAS原子操作， JUC强大的高并发性能是建立在CAS原子之上的。CAS操作中包含三个操作数：需要操作的内存位置（V）、进行比较的预期原值（A）和拟写入的新值 （B） 。 如果内存位置V的值与预期原值A相匹配， 那么处理器会自动将该位置值更新为新值B；否则CPU不做任何操作。

CAS操作可以非常清晰地分为两个步骤：

1）检测位置V的值是否为A。

2）如果是，将位置V更新为B值；否则不要更改该位置。CAS的两个操作步骤其实与乐观锁操作的两个步骤是一致的， 都是在冲突检测后进行数据更新。

实际上，如果需要完成数据的最终更新，仅仅进行一次CAS操作是不够的，一般情况下，需要进行自旋操作，即不断地循环重试CAS操作直到成功，这也叫CAS自旋。

通过CAS自旋，在不使用锁的情况下实现多线程之间的变量同步，也就是说，在没有线程被阻塞的情况下实现变量的同步，这叫作“非阻塞同步”（Non-Blocking Synchronization），或者说“无锁同步”。使用基于CAS自旋的乐观锁进行同步控制，属于无锁编程（Lock Free）的一种实践。

#### 不可重入的自旋锁

自旋锁（SpinLock）的基本含义为：当一个线程在获取锁的时候，如果锁已经被其他线程获取，调用者就一直在那里循环检查该锁是否已经被释放，一直到获取到锁才会退出循环。

CAS自旋锁的实现原理为：抢锁线程不断进行CAS自旋操作去更新锁的owner（拥有者），如果更新成功，表明已经抢锁成功，退出抢锁方法。如果锁已经被其他线程获取（也就是owner为其他线程），调用者就一直在那里循环进行owner的CAS更新操作，一直到成功才会退出循环。

```java
public class SpinLock implements Lock{
  /**当前锁的拥有者
  * 使用Thread 作为同步状态
  */
  private AtomicReference<Thread> owner = new AtomicReference<>();
  /**
  * 抢占锁
  */
  @Override
  public void lock(){
    Thread t = Thread.currentThread();
    //自旋
    while (!owner.compareAndSet(null, t)){
      // DO nothing
      Thread.yield();//让出当前剩余的CPU时间片
    }
  }
  
  /**
  * 释放锁
  */
  @Override
  public void unlock(){
    Thread t = Thread.currentThread();
    //只有拥有者才能释放锁
    if (t == owner.get()){
      // 设置拥有者为空，这里不需要 compareAndSet操作
      // 因为已经通过owner做过线程检查
      owner.set(null);
    }
  }
  // 省略其他代码
}
```



#### 可重入的自旋锁

自旋锁的特点：线程获取锁的时候，如果锁被其他线程持有，当前线程将循环等待，直到获取到锁。线程抢锁期间状态不会改变，一直是运行状态（RUNNABLE），在操作系统层面线程处于用户态。

自旋锁的问题：在争用激烈的场景下，如果某个线程持有锁的时间太长，就会导致其他空自旋的线程耗尽CPU资源。 另外， 如果大量的线程进行空自旋， 还可能导致硬件层面的“总线风暴”。

```java
public class ReentrantSpinLock implements Lock{
  /**当前锁的拥有者
  * 使用拥有者Thread作为同步状态，而不是使用一个简单的整数作为同步状态
  */
  private AtomicReference<Thread> owner = new AtomicReference<>();
  /**
  * 记录一个线程重复获取锁的次数
  * 此变量为同一个线程在操作，没有必要加上volatile保障可见性和有序性
  */
  private int count = 0;
  
  /**
  * 抢占锁
  */
  @Override
  public void lock(){
    Thread t = Thread.currentThread();
    // 如果是重入，增加重入次数后返回
    if (t == owner.get()){
      ++count;
      return;
    }
    //自旋
    while (owner.compareAndSet(null, t)){
      // DO nothing
      Thread.yield(); //让出当前剩余的CPU时间片
    }
  }
  
  /**
  * 释放锁
  */
  @Override
  public void unlock(){
    Thread t = Thread.currentThread();
    //只有拥有者才能释放锁
    if (t == owner.get()){
      if (count > 0){
        // 如果重入的次数大于0，减少重入次数后返回
        --count;
      } else{
        // 设置拥有者为空
        //这里不需要compareAndSet，因为已经通过owner做过线程检查
        owner.set(null);
      }
    }
  }
  // 省略其他代码
}
```

#### CAS 可能导致“总线风暴”

sun.misc.Unsafe类的compareAndSwapInt() 底层会根据当前CPU的类型是否为多核CPU来决定是否为cmpxchg指令添加lock前缀。

如果程序是在多核CPU上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。 反之，如果程序是在单核CPU上运行，就省略lock前缀，因为单核CPU不需要lock前缀提供的内存屏障效果。

由于使用lock前缀指令的Java操作（包括CAS、volatile）恰恰会产生缓存一致性流量，当有很多线程都同时执行lock前缀指令操作时，在SMP架构的CPU平台上必然会导致总线风暴。

前面讲到， 在争用激烈场景下， Java轻量级锁会快速膨胀为重量级锁， 其本质上一是为了减少CAS空自旋，二是为了避免同一时间大量CAS操作所导致的总线风暴。

那么， JUC基于CAS实现的轻量级锁如何避免总线风暴呢？答案是： 使用队列对抢锁线性进行排队，最大程度上减少了CAS操作数量。

#### CLH 自旋锁

CLH锁其实就是一种是基于队列（具体为单向链表）排队的自旋锁，由于是Craig、Landin和Hagersten三人一起发明的，因此被命名为CLH锁，也叫CLH队列锁。

简单的CLH锁可以基于单向链表实现，申请加锁的线程首先会通过CAS操作在单向链表的尾部增加一个节点， 之后该线程只需要在其前驱节点上进行普通自旋， 等待前驱节点释放锁即可。 由于CLH锁只有在节点入队时进行一下CAS的操作，在节点在加入队列之后，抢锁线程不需要进行CAS自旋， 只需普通自旋即可。 因此， 在争用激烈的场景下， CLH锁能大大减少的CAS操作的数量，以避免CPU的总线风暴。

> JUC中显式锁基于AQS抽象队列同步器， 而AQS是CLH锁的一个变种

#### 公平锁与非公平锁

synchronized内置锁是一种非公平锁，默认情况下ReentrantLock锁也是非公平锁。

什么是非公平锁呢？非公平锁是指多个线程获取锁的顺序并不一定是其申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，抢锁成功的次序不一定体现为FIFO（先进先出）顺序。 非公平锁的优点在于吞吐量比公平锁大， 其缺点是有可能会导致线程优先级反转或者线程饥饿现象。

什么是公平锁呢？公平锁是指多个线程按照申请锁的顺序来获取锁，抢锁成功的次序体现为FIFO（先进先出）顺序。虽然ReentrantLock锁默认是非公平锁，但可以通过构造器指定该锁为公平锁。

#### 可中断锁与不可中断锁

可中断锁是指抢占过程是可以被中断的锁， JUC的显式锁 （如ReentrantLock） 是一个可中断锁。不可中断锁是指抢占过程是不可以被中断的锁，如Java的synchronized内置锁就是一个不可中断锁。

在JUC的显式锁Lock接口中，有以下两个方法可以用于可中断抢占：

（1）lockInterruptibly()

可中断抢占锁，抢占过程中会处理Thread.interrupt()中断信号，如果线程被中断，则会终止抢占并抛出InterruptedException异常。

（2）tryLock(long timeout, TimeUnit unit)

阻塞式“限时抢占”（在timeout时间内）锁抢占过程中会处理Thread.interrupt()中断信号，如果线程被中断，就会终止抢占并抛出InterruptedException异常。



死锁是指两个或以上线程因抢占锁而造成的互相等待的现象。多个线程通过AB-BA模式抢占两个锁是造成多线程死锁的比较普遍的原因。 AB-BA模式的死锁具体表现为： 线程X先后按照先后次序去抢占锁A与锁B， 线程Y先后按照先后次序去抢占锁B与锁A； 当线程X抢到锁A去抢占锁B时，发现已经被其他线程拿走，然而线程Y拿到锁B后去抢占A锁时，发现已经被其他线程拿走；于是线程X等待其他线程释放锁B，线程Y等待其他线程释放锁A，两个线程互相等待从而造成死锁。

JDK 8中包含的ThreadMXBean接口提供了多种监视线程的方法，其中包括了两个死锁监测的方法，具体如下：

（1）findDeadlockedThreads

用于检测由于抢占JUC显式锁、Java内置锁所引起死锁的线程。

（2）findMonitorDeadlockedThreads

仅仅用于检测由于抢占Java内置锁所引起死锁的线程。



如果是可中断抢占锁（如使用lockInterruptibly()方法等），就可以在监测到死锁发生之后，使用Thread.interrupt()去中断死锁线程，不让死锁线程一直等下去。



#### 独占锁与共享锁

在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。按照是否“允许在同一时刻被多个线程持有”来区分，锁可以分为独占锁与共享锁。



独占锁也叫排他锁、互斥锁、独享锁，是指锁在同一时刻只能被一个线程锁所持有。一个线程加锁后， 任何其他试图再次加锁的线程会被阻塞， 直到持有锁线程解锁。 通俗来说， 就是共享资源某一时刻只能有一个线程访问，其余线程阻塞等待。

如果是公平地独占锁，在持有锁线程解锁时，如果有一个以上的线程在阻塞等待，那么最先抢锁的线程被唤醒变为就绪状态去执行加锁操作，其他的线程仍然阻塞等待。Java中Synchronized内置锁和ReentrantLock显式锁都是独占锁。



共享锁就是在同一时刻允许多个线程持有的锁。当然，获得共享锁的线程只能读取临界区数据，不能修改临界区的数据。

JUC中的共享锁包括Semaphore（信号量）、ReadLock（读写锁）中的读锁、CountDownLatch倒数闩。

Semaphore可以用来控制在同一时刻访问共享资源的线程数量， 通过协调各个线程以保证共享资源的合理使用。Semaphore维护了一组虚拟许可，其数量可以通过构造器的参数指定。线程在访问共享资源前必须使用Semaphore的acquire()方法获得许可， 如果许可数量为0， 该线程就一直阻塞。线程访问完成资源后，必须使用Semaphore的release()方法释放许可。更形象的说法是：Semaphore是一个是许可管理器。



CountDownLatch 是 一 个 常 用 的 共 享 锁 ， 其 功 能 相 当 于 一 个 多 线 程 环 境 下 的 倒 数 门 闩 。

CountDownLatch可以指定一个计数值，在并发环境下由线程进行减1操作，当计数值变为0之后，被await方法阻塞的线程将会唤醒。通过CountDownLatch可以实现线程间的计数同步。



#### 读写锁

读写锁的内部包含了两把锁：

一把是为读（操作）锁，是一种共享锁；另一把写（操作）锁，是一种独占锁。 在没有写锁的时候， 读锁可以被多个线程同时持有。 写锁是排他性的： 如果写锁被

一个线程持有， 其他的线程不能再持有写锁， 抢占写锁会阻塞； 进一步来说， 如果写锁被一个线程持有，其他的线程不能再持有读锁，抢占读锁也会阻塞。

读写锁的读写操作之间的互斥原则具体如下：

- 读操作、读操作能共存，是相容的。

- 读操作、写操作不能共存，是互斥的。

- 写操作、写操作不能共存，是互斥的。

与单一的互斥锁相比，组合起来的读写锁允许对于共享数据进行更大程度的并发操作。虽然每次只能有一个写线程，但是同时可以有多个线程并发地读数据。读写锁适用于读多写少的并发情况。



通过ReentrantReadWriteLock类能获取其读锁和写锁，其读锁是可以多线程共享的共享锁，而其写锁是排他锁， 在被占时候不允许其他线程再抢占操作。 然而其读锁和写锁之间是有关系的： 同一时刻不允许读锁和写锁同时被抢占，二者之间是互斥的。



锁升级是指读锁升级为写锁，锁降级指的是写锁降级为读锁。在ReentrantReadWriteLock读写锁中，只支持写锁降级为读锁，而不支持读锁升级为写锁。



ReentrantReadWriteLock不支持读锁的升级，主要是避免死锁，例如两个线程A和B都占了读锁并且都需要升级成写锁，A升级要求B释放读锁，B升级要求A释放读锁，二者就会由于互相等待形成死锁。

总结起来，与ReentrantLock相比，ReentrantReadWriteLock更适合于读多写少的场景，可以提高并发读的效率；而ReentrantLock更适合于读写比例相差不大或写比读多的场景。



StampedLock （印戳锁） 是对ReentrantReadWriteLock读写锁的一种改进， 主要的改进为： 在没有写只有读的场景下， StampedLock支持不用加读锁而是直接进行读操作， 最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作。

StampedLock的三种模式如下：

1）悲观读锁：与ReadWriteLock的读锁类似，多个线程可以同时获取悲观读锁，悲观读锁是一个共享锁。

2）乐观读：相当于直接操作数据，不加任何锁，连读锁都不要。

3）写锁：与ReadWriteLock的写锁类似，写锁和悲观读锁是互斥的；虽然写锁与乐观读不会互斥，但是在数据被更新之后，之前通过乐观读所获得的数据已经变成了脏数据。

### JUC 容器类

## 高并发设计模式

### Master-Worker 模式

Master-Worker模式是一种常见的高并发模式，它的核心思想是任务的调度和执行分离，调度任务的角色为Master，执行任务的角色为Worker，Master负责接收和、分配任务和合并（Merge）任务结果，Worker负责执行任务。Master-Worker模式是一种归并类型的模式。

举一个例子，在TCP服务端的请求处理过程中，大量的客户端连接相当于大量的任务，Master需要将这些存储在一个任务队列中，然后分发给各个Worker，每个Worker是一个工作线程，负责完成连接的传输处理。

### ForkJoin 模式

### 生产者－消费者模式

### Future 模式

### 异步回调模式
